{"version":3,"sources":["sci/impl/interpreter.cljc"],"mappings":";AAeA,AAAKA,AAAM,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAACC;AACZ,AAAA,AAAMC,AAAcC,AAAKC,AAAEC;AAA3B,AACE,AAACC,AAAMN,AAAM,AAAKO;AAAL,AACMA,AACA,AAACC,AAAOJ,AAAEK,AAAEJ,AACZ,AAAA,AAACG,AAAcC,AAAEJ;;;AAEtC,AAAA,AAAMK;AAAN,AACE,AAACC,AAAI,AAACC,AAAO,AAAA,AAAAC,AAACC,AAAMd,AACP,AAAA,AAAAe,AAACC;AAAD,AAAM,AAAA,AAAGD;AAAsB,AAAA,AAAAF,AAACI,AAAMjB;;AAErD,AAAA,AAAMkB,AAAiBC,AAAIC;AAA3B,AACE,AAAI,AAACC,AAAKD;AACR,AAAI,AAAA,AAAA,AAACE,AAAM,AAACC,AAAMH;AAChB,AAAOI,AAAM,AAACC,AAAKL;AAAnB,AACOM;;AADP,AAEE,AAAI,AAACC,AAAIH;AACP,AACC,AAACC,AAAKD;AACN,AAAAI,AAAiBT;AAAjBU,AAAqB,AAACN,AAAMC;AAA5B,AAAA,AAAAI,AAAAC,AAAAD,AAAAC,AAACX,AAAAA,AAAAA;;;;;;AACFQ;;;;;AACJ,AAAM,AAAI,AAACI,AAAI,AAAA,AAAaX,AAClB,AAAA,AAAA,AAACG,AAAM,AAACC,AAAMH,AACd,AAAA,AAAA,AAACE,AAAW,AAACC,AAAMH;AAF7B,AAGE,AACMW,AAAS,AAAA,AAACC,AAAYb,AAAIC;AAG1BM,AAAI,AAAI,AAAWO,AAAwBF,AACrC,AAAAG,AAAiBf;AAAjBgB,AAAqB,AAAUJ;AAA/B,AAAA,AAAAG,AAAAC,AAAAD,AAAAC,AAACjB,AAAAA,AAAAA;AACD,AACMQ,AAAI,AAACU,AAAUjB,AAAIY;AADzB,AAIEL;;AAVd,AAWEA;;AAdJ;;;;AAeF,AACMK,AAAS,AAACC,AAAYb,AAAIC;AAI1BM,AAAI,AAACU,AAAUjB,AAAIY;AALzB,AAQEL;;;AAEN,AAAA,AAAMW,AAAWlB,AAAIC;AAArB,AACE,AAAI,AAACC,AAAKD;AACR,AAAI,AAAA,AAAA,AAACE,AAAM,AAACC,AAAMH;AAChB,AAAOI,AAAM,AAACC,AAAKL;AAAnB,AACOM;;AADP,AAEE,AAAI,AAACC,AAAIH;AACP,AACC,AAACC,AAAKD;AACN,AAAAc,AAAWnB;AAAXoB,AAAe,AAAChB,AAAMC;AAAtB,AAAA,AAAAc,AAAAC,AAAAD,AAAAC,AAACF,AAAAA,AAAAA;;;;;;AACFX;;;;;AACJ,AAAM,AAAI,AAACI,AAAI,AAAA,AAAaX,AAClB,AAAA,AAAA,AAACG,AAAM,AAACC,AAAMH,AACd,AAAA,AAAA,AAACE,AAAW,AAACC,AAAMH;AAF7B,AAGE,AAAMW,AAAS,AAAA,AAACC,AAAYb,AAAIC;AAC1BM,AAAI,AAAI,AAAWO,AAAwBF,AACrC,AAAAS,AAAWrB;AAAXsB,AAAe,AAAUV;AAAzB,AAAA,AAAAS,AAAAC,AAAAD,AAAAC,AAACJ,AAAAA,AAAAA;AACD,AAACD,AAAUjB,AAAIY;AAH3B,AAIEL;;AAPJ;;;;AAQF,AAAMK,AAAS,AAACC,AAAYb,AAAIC;AAC1BM,AAAI,AAACU,AAAUjB,AAAIY;AADzB,AAEEL;;;AAMN,AAACgB,AAAQC,AAAsBN;AAG/B,AAAA,AAAMO,AAAmBzB,AAAI0B;AAA7B,AACE,AAAM1B,AAAI,AAAA,AAAC2B,AAAM3B,AAAQ,AAAA4B,AAAI,AAAA,AAAK5B;AAAT,AAAA,AAAA4B;AAAAA;;AAAc,AAACC;;;AAAxC,AACE,AAAA,AAAAC,AAAA,AAAA,AAAApC,AAAqBsC,AAAiBA;;AAAtC,AAAA,AAAA,AACE,AAAMC,AAAO,AAACC,AAA4B,AAACC,AAA0BT;AAArE,AACE,AAAA,AAAOnB;;AAAP,AACE,AACM6B,AAAK,AAACC,AAAarC,AAAIiC;AAD7B,AAIE,AAAI,AAACK,AAAAA,AAAAA,AAAoBC,AAAA,AAAAA,AAAA,AAAMH,AAAAA;AAC7B,AACE,AAAC7C;;AACDgB;;AACF,AAAMA,AAAI,AAACW,AAAUlB,AAAIoC;AAAzB,AACE,AAAO7B;;;;;;AAZnB,AAAA,AAAAwB;;AAcJ,AAAA,AAAMS,AAAcxC,AAAI0B;AAAxB,AACE,AAAM1B,AAAI,AAAA,AAAC2B,AAAM3B,AAAQ,AAAA4B,AAAI,AAAA,AAAK5B;AAAT,AAAA,AAAA4B;AAAAA;;AAAc,AAACC;;;AAAxC,AACE,AAAA,AAAAC,AAAA,AAAA,AAAApC,AAAqBsC,AAAiBA;;AAAtC,AAAA,AAAA,AACE,AAAMC,AAAO,AAACC,AAA4B,AAACC,AAA0BT;AAArE,AACE,AAAA,AAAOnB;;AAAP,AACE,AAAM6B,AAAK,AAACC,AAAarC,AAAIiC;AAA7B,AACE,AAAI,AAACK,AAAAA,AAAAA,AAAoBC,AAAA,AAAAA,AAAA,AAAMH,AAAAA;AAC7B7B;;AACA,AAAMA,AAAI,AAACW,AAAUlB,AAAIoC;AAAzB,AACE,AAAO7B;;;;;;AAPnB,AAAA,AAAAwB;;AAaJ,AAACR,AAAQkB,AAAmBD;AAI5B,AAAA,AAAA,AAAAE,AAAME;AAAN,AAAA,AAAAD,AAAA,AAAA;AAAA,AAAA,AAAAA;AAAA;AAAA,AAAAC,AAAA,AAAA,AAAA;;;AAAA;AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;;;;AAAA,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA;;;;;AAAA,AAAA,AAAA,AAAMD,AACFlB;AADJ,AACO,AAAA,AAACoB,AAAYpB;;;AADpB,AAAA,AAAA,AAAMkB,AAEFlB,AAAEqB;AAFN,AAGG,AAAMC,AAAS,AAACC,AAAUF;AACpBxC,AAAI,AAACiC,AAAaQ,AAAStB;AADjC,AAEEnB;;;AALL,AAAA,AAAA,AAAMqC;;AAAN,AASA","names":["sci.impl.interpreter/stats","cljs.core.atom","sci.impl.interpreter/update-stats","_ctx","k","t","cljs.core.swap_BANG_","stats","cljs.core.update","cljs.core/+","sci.impl.interpreter/print-stats","cljs.core.prn","cljs.core/zipmap","cljs.core/deref","cljs.core/keys","p1__58338#","cljs.core.map","cljs.core/vals","sci.impl.interpreter/eval-form-stats","ctx","form","cljs.core/seq?","cljs.core._EQ_","cljs.core/first","exprs","cljs.core/rest","ret","cljs.core/seq","G__58353","G__58354","cljs.core/not","analyzed","sci.impl.analyzer.analyze","sci.impl.types/EvalForm","G__58358","G__58359","sci.impl.evaluator/eval","sci.impl.interpreter/eval-form","G__58365","G__58366","G__58370","G__58371","cljs.core/vreset!","sci.impl.utils/eval-form-state","sci.impl.interpreter/eval-string-stats","s","cljs.core.assoc","or__4126__auto__","cljs.core.gensym","sci.impl.vars/push-thread-bindings","sci.impl.vars/pop-thread-bindings","sci.impl.vars/current-ns","reader","cljs.tools.reader.reader_types.indexing_push_back_reader","cljs.tools.reader.reader_types.string_push_back_reader","expr","sci.impl.parser.parse_next","sci.impl.utils/kw-identical?","sci.impl.parser/eof","sci.impl.interpreter/eval-string*","sci.impl.utils/eval-string*","var_args","G__58379","sci.impl.interpreter/eval-string","js/Error","sci.impl.interpreter.eval_string","opts","init-ctx","sci.impl.opts/init"],"sourcesContent":["(ns sci.impl.interpreter\n  {:no-doc true}\n  (:refer-clojure :exclude [destructure macroexpand macroexpand-1])\n  (:require\n   [clojure.tools.reader.reader-types :as r]\n   [sci.impl.analyzer :as ana]\n   [sci.impl.evaluator :as eval]\n   [sci.impl.opts :as opts]\n   [sci.impl.parser :as p]\n   [sci.impl.types :as t]\n   [sci.impl.utils :as utils]\n   [sci.impl.vars :as vars]))\n\n#?(:clj (set! *warn-on-reflection* true))\n\n(def stats (atom {:parse 0 :analysis 0 :eval 0 :total 0}))\n(defn update-stats [_ctx k t]\n  (swap! stats (fn [stats]\n                 (-> stats\n                     (update k + t)\n                     (update :total + t)))))\n\n(defn print-stats []\n  (prn (zipmap (keys @stats)\n               (map #(/ (double %) 1000000.0) (vals @stats)))))\n\n(defn eval-form-stats [ctx form]\n  (if (seq? form)\n    (if (= 'do (first form))\n      (loop [exprs (rest form)\n             ret nil]\n        (if (seq exprs)\n          (recur\n           (rest exprs)\n           (eval-form-stats ctx (first exprs)))\n          ret))\n      (when (or (not (:uberscript ctx))\n                (= 'ns (first form))\n                (= 'require (first form)))\n        (let [#?@(:clj [a0 (System/nanoTime)])\n              analyzed (ana/analyze ctx form true)\n              #?@(:clj [a1 (System/nanoTime)\n                        _ (update-stats ctx :analysis (- a1 a0))])\n              ret (if (instance? sci.impl.types.EvalForm analyzed)\n                    (eval-form-stats ctx (t/getVal analyzed))\n                    (let [#?@(:clj [e0 (System/nanoTime)])\n                          ret (eval/eval ctx analyzed)\n                          #?@(:clj [e1 (System/nanoTime)\n                                    _ (update-stats ctx :eval (- e1 e0))])]\n                      ret))]\n          ret)))\n    (let [#?@(:clj [t0 (System/nanoTime)])\n          analyzed (ana/analyze ctx form)\n          #?@(:clj [t1 (System/nanoTime)\n                    _ (update-stats ctx :analysis (- t1 t0))])\n          #?@(:clj [t0 (System/nanoTime)])\n          ret (eval/eval ctx analyzed)\n          #?@(:clj [t1 (System/nanoTime)\n                    _ (update-stats ctx :eval (- t1 t0))])]\n      ret)))\n\n(defn eval-form [ctx form]\n  (if (seq? form)\n    (if (= 'do (first form))\n      (loop [exprs (rest form)\n             ret nil]\n        (if (seq exprs)\n          (recur\n           (rest exprs)\n           (eval-form ctx (first exprs)))\n          ret))\n      (when (or (not (:uberscript ctx))\n                (= 'ns (first form))\n                (= 'require (first form)))\n        (let [analyzed (ana/analyze ctx form true)\n              ret (if (instance? sci.impl.types.EvalForm analyzed)\n                    (eval-form ctx (t/getVal analyzed))\n                    (eval/eval ctx analyzed))]\n          ret)))\n    (let [analyzed (ana/analyze ctx form)\n          ret (eval/eval ctx analyzed)]\n      ret)))\n\n#?(:clj\n   (when (System/getenv \"SCI_STATS\")\n     (alter-var-root #'eval-form (constantly eval-form-stats))))\n\n(vreset! utils/eval-form-state eval-form)\n\n;; with stats\n(defn eval-string-stats [ctx s]\n  (let [ctx (assoc ctx :id (or (:id ctx) (gensym)))]\n    (vars/with-bindings {vars/current-ns @vars/current-ns}\n      (let [reader (r/indexing-push-back-reader (r/string-push-back-reader s))]\n        (loop [ret nil]\n          (let [#?@(:clj [t0 (System/nanoTime)])\n                expr (p/parse-next ctx reader)\n                #?@(:clj [t1 (System/nanoTime)\n                          _ (update-stats ctx :parse (- t1 t0))])]\n            (if (utils/kw-identical? p/eof expr)\n              (do\n                (print-stats)\n                ret)\n              (let [ret (eval-form ctx expr)]\n                (recur ret)))))))))\n\n(defn eval-string* [ctx s]\n  (let [ctx (assoc ctx :id (or (:id ctx) (gensym)))]\n    (vars/with-bindings {vars/current-ns @vars/current-ns}\n      (let [reader (r/indexing-push-back-reader (r/string-push-back-reader s))]\n        (loop [ret nil]\n          (let [expr (p/parse-next ctx reader)]\n            (if (utils/kw-identical? p/eof expr)\n              ret\n              (let [ret (eval-form ctx expr)]\n                (recur ret)))))))))\n\n#?(:clj\n   (when (System/getenv \"SCI_STATS\")\n     (alter-var-root #'eval-string* (constantly eval-string-stats))))\n\n(vreset! utils/eval-string* eval-string*)\n\n;;;; Called from public API\n\n(defn eval-string\n  ([s] (eval-string s nil))\n  ([s opts]\n   (let [init-ctx (opts/init opts)\n         ret (eval-string* init-ctx s)]\n     ret)))\n\n;;;; Scratch\n\n(comment\n  (eval-string \"((fn f [x] (if (< x 3) (recur (inc x)) x)) 0)\")\n  )\n"]}