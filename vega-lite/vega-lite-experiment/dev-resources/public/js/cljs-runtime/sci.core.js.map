{"version":3,"sources":["sci/core.cljc"],"mappings":"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","names":["var_args","G__59154","sci.core/new-var","js/Error","name","G__59155","sci.core.new_var","sci.impl.vars/unbind","init-val","cljs.core/meta","meta","sci.impl.vars/SciVar","G__59158","sci.core/new-dynamic-var","G__59159","sci.core.new_dynamic_var","cljs.core.assoc","sci.core/set!","dynamic-var","v","sci.impl.types/setVal","G__59161","sci.core/new-macro-var","sci.core.new_macro_var","cljs.core.vary_meta","cljs.core/assoc","sci.core/in","sci.impl.io/in","sci.core/out","sci.impl.io/out","sci.core/err","sci.impl.io/err","sci.core/ns","sci.impl.vars/current-ns","sci.core/file","sci.impl.vars/current-file","sci.core/print-length","sci.impl.io/print-length","sci.core/print-level","sci.impl.io/print-level","sci.core/print-meta","sci.impl.io/print-meta","sci.core/*1","sci.impl.namespaces/*1","sci.core/*2","sci.impl.namespaces/*2","sci.core/*3","sci.impl.namespaces/*3","sci.core/*e","sci.impl.namespaces/*e","args__4742__auto__","len__4736__auto__","i__4737__auto__","argseq__4743__auto__","cljs.core/IndexedSeq","sci.core/alter-var-root","seq59176","G__59177","cljs.core/first","cljs.core/next","G__59178","self__4723__auto__","f","args","cljs.core.apply","sci.impl.vars/alter-var-root","G__59183","sci.core/eval-string","s","sci.core.eval_string","opts","sci.impl.interpreter.eval_string","sci.core/init","sci.impl.opts/init","sci.core/fork","ctx","cljs.core.update","env","cljs.core/deref","cljs.core.atom","sci.core/eval-string*","sci.impl.interpreter/eval-string*","G__59188","sci.core/create-ns","sym","sci.core.create_ns","sci.impl.vars/->SciNamespace","sci.core/parse-string","sci.impl.parser/parse-string","sci.core/reader","x","sci.impl.parser/reader","sci.core/get-line-number","reader","sci.impl.parser/get-line-number","sci.core/get-column-number","sci.impl.parser/get-column-number","G__59193","sci.core/parse-next","sci.core.parse_next","sci.impl.parser.parse_next","sci.impl.utils/kw-identical?","sci.impl.parser/eof","or__4126__auto__","cljs.core.get","sci.core/eval-form","form","cljs.core.gensym","sci.impl.interpreter/eval-form"],"sourcesContent":["(ns sci.core\n  (:refer-clojure :exclude [with-bindings with-in-str with-out-str\n                            with-redefs binding future pmap alter-var-root\n                            ns create-ns set! *1 *2 *3 *e])\n  (:require\n   [sci.impl.interpreter :as i]\n   [sci.impl.io :as sio]\n   [sci.impl.macros :as macros]\n   [sci.impl.namespaces :as namespaces]\n   [sci.impl.opts :as opts]\n   [sci.impl.parser :as parser]\n   [sci.impl.types :as t]\n   [sci.impl.utils :as utils]\n   [sci.impl.vars :as vars])\n  #?(:cljs (:require-macros\n            [sci.core :refer [with-bindings with-out-str copy-var]])))\n\n#?(:clj (set! *warn-on-reflection* true))\n\n(defn new-var\n  \"Returns a new sci var.\"\n  ([name] (doto (new-var name nil nil)\n            (vars/unbind)))\n  ([name init-val] (new-var name init-val (meta name)))\n  ([name init-val meta] (sci.impl.vars.SciVar. init-val name meta false)))\n\n(defn new-dynamic-var\n  \"Same as new-var but adds :dynamic true to meta.\"\n  ([name] (doto (new-dynamic-var name nil nil)\n            (vars/unbind)))\n  ([name init-val] (new-dynamic-var name init-val (meta name)))\n  ([name init-val meta] (sci.impl.vars.SciVar. init-val name (assoc meta :dynamic true) false)))\n\n(defn set!\n  \"Establish thread local binding of dynamic var\"\n  [dynamic-var v]\n  (t/setVal dynamic-var v))\n\n(defn new-macro-var\n  \"Same as new-var but adds :macro true to meta as well\n  as :sci/macro true to meta of the fn itself.\"\n  ([name init-val] (new-macro-var name init-val (meta name)))\n  ([name init-val meta] (sci.impl.vars.SciVar.\n                         (vary-meta init-val\n                                    assoc :sci/macro true)\n                         name (assoc meta :macro true) false)))\n\n(defmacro copy-var\n  \"Copies contents from var `sym` to a new sci var. The value `ns` is an\n  object created with `sci.core/create-ns`.\"\n  ([sym ns]\n   `(let [ns# ~ns\n          var# (var ~sym)\n          val# (deref var#)\n          m# (-> var# meta)\n          ns-name# (vars/getName ns#)\n          name# (:name m#)\n          name-sym# (symbol (str ns-name#) (str name#))\n          new-m# {:doc (:doc m#)\n                  :name name#\n                  :arglists (:arglists m#)\n                  :ns ns#}]\n      (cond (:dynamic m#)\n            (new-dynamic-var name# val# new-m#)\n            (:macro m#)\n            (new-macro-var name# val# new-m#)\n            :else (new-var name# val# new-m#)))))\n\n(macros/deftime\n  (defmacro with-bindings\n    \"Macro for binding sci vars. Must be called with map of sci dynamic\n  vars to values. Used in babashka.\"\n    [bindings-map & body]\n    `(let [bm# ~bindings-map]\n       (assert (map? bm#))\n       (vars/push-thread-bindings bm#) ;; important: outside try\n       (try\n         (do ~@body)\n         (finally (vars/pop-thread-bindings)))))\n\n  (defmacro binding\n    \"Macro for binding sci vars. Must be called with a vector of sci\n  dynamic vars to values.\"\n    [bindings & body]\n    (assert (vector? bindings))\n    (assert (even? (count bindings)))\n    `(with-bindings ~(apply hash-map bindings)\n       (do ~@body))))\n\n(def in \"Sci var that represents sci's `clojure.core/*in*`\" sio/in)\n(def out \"Sci var that represents sci's `clojure.core/*out*`\" sio/out)\n(def err \"Sci var that represents sci's `clojure.core/*err*`\" sio/err)\n(def ns \"Sci var that represents sci's `clojure.core/*ns*`\" vars/current-ns)\n(def file \"Sci var that represents sci's `clojure.core/*file*`\" vars/current-file)\n(def print-length \"Sci var that represents sci's `clojure.core/*print-length*`\" sio/print-length)\n(def print-level \"Sci var that represents sci's `clojure.core/*print-level*`\" sio/print-level)\n(def print-meta \"Sci var that represents sci's `clojure.core/*print-meta*`\" sio/print-meta)\n(def *1 namespaces/*1)\n(def *2 namespaces/*2)\n(def *3 namespaces/*3)\n(def *e namespaces/*e)\n\n;; REPL variables\n\n\n(macros/deftime\n  (defmacro with-in-str\n    \"Evaluates body in a context in which sci's *in* is bound to a fresh\n  StringReader initialized with the string s.\"\n    [s & body]\n    `(let [in# (-> (java.io.StringReader. ~s)\n                   (clojure.lang.LineNumberingPushbackReader.))]\n       (with-bindings {in in#}\n         (do ~@body)))))\n\n(macros/deftime\n  (defmacro with-out-str\n    \"Evaluates exprs in a context in which sci's *out* is bound to a fresh\n  StringWriter.  Returns the string created by any nested printing\n  calls.\"\n    [& body]\n    `(let [out# (macros/? :clj (java.io.StringWriter.)\n                          :cljs (goog.string/StringBuffer.))]\n       (with-bindings {out out#}\n         (do ~@body)\n         (str out#)))))\n\n(macros/deftime\n  (defmacro future\n    \"Like clojure.core/future but also conveys sci bindings to the thread.\"\n    [& body]\n    `(let [f# (-> (fn [] ~@body)\n                  (vars/binding-conveyor-fn))]\n       (future-call f#))))\n\n#?(:clj (defn pmap\n          \"Like clojure.core/pmap but also conveys sci bindings to the threads.\"\n          ([f coll]\n           (let [n (+ 2 (.. Runtime getRuntime availableProcessors))\n                 rets (map #(future (f %)) coll)\n                 step (fn step [[x & xs :as vs] fs]\n                        (lazy-seq\n                         (if-let [s (seq fs)]\n                           (cons (deref x) (step xs (rest s)))\n                           (map deref vs))))]\n             (step rets (drop n rets))))\n          ([f coll & colls]\n           (let [step (fn step [cs]\n                        (lazy-seq\n                         (let [ss (map seq cs)]\n                           (when (every? identity ss)\n                             (cons (map first ss) (step (map rest ss)))))))]\n             (pmap #(apply f %) (step (cons coll colls)))))))\n\n(defn alter-var-root\n  \"Atomically alters the root binding of sci var v by applying f to its\n  current value plus any args.\"\n  [v f & args]\n  (apply vars/alter-var-root v f args))\n\n(defn eval-string\n  \"Evaluates string `s` as one or multiple Clojure expressions using the Small Clojure Interpreter.\n\n  The map `opts` may contain the following:\n\n  - `:namespaces`: a map of symbols to namespaces, where a namespace\n  is a map with symbols to values, e.g.: `{'foo.bar {'x 1}}`. These\n  namespaces can be used with `require`.\n\n  - `:bindings`: `:bindings x` is the same as `:namespaces {'user x}`.\n\n  - `:allow`: a seqable of allowed symbols. All symbols, even those\n  brought in via `:bindings` or `:namespaces` have to be explicitly\n  enumerated.\n\n  - `:deny`: a seqable of disallowed symbols, e.g.: `[loop quote\n  recur]`.\n\n  - `:features`: when provided a non-empty set of keywords, sci will process reader conditionals using these features (e.g. #{:bb}).\n\n  - `:env`: an atom with a map in which state from the\n  evaluation (defined namespaced and vars) will be persisted for\n  re-use over multiple calls.\n\n  - `:disable-arity-checks`: disables arity checks for single-arity\n  functions.\"\n  ([s] (eval-string s nil))\n  ([s opts]\n   (i/eval-string s opts)))\n\n(defn init\n  \"Creates an initial sci context from given options `opts`. The context\n  can be used with `eval-string*`. See `eval-string` for available\n  options. The internal organization of the context is implementation\n  detail and may change in the future.\"\n  [opts]\n  (opts/init opts))\n\n(defn fork\n  \"Forks a context (as produced with `init`) into a new context. Any new\n  vars created in the new context won't be visible in the original\n  context.\"\n  [ctx]\n  (update ctx :env (fn [env] (atom @env))))\n\n(defn eval-string*\n  \"Evaluates string `s` in the context of `ctx` (as produced with\n  `init`).\"\n  [ctx s]\n  (sci.impl.interpreter/eval-string* ctx s))\n\n(defn create-ns\n  \"Creates namespace object. Can be used in var metadata.\"\n  ([sym] (create-ns sym nil))\n  ([sym meta]\n   (vars/->SciNamespace sym meta)))\n\n(defn parse-string\n  \"Parses string `s` in the context of `ctx` (as produced with\n  `init`).\"\n  ([ctx s]\n   (parser/parse-string ctx s)))\n\n(defn reader\n  \"Coerces x into indexing pushback-reader to be used with\n  parse-next. Accepts: string or java.io.Reader.\"\n  [x]\n  (parser/reader x))\n\n(defn get-line-number [reader]\n  (parser/get-line-number reader))\n\n(defn get-column-number [reader]\n  (parser/get-column-number reader))\n\n(defn parse-next\n  \"Parses next form from reader\"\n  ([ctx reader] (parse-next ctx reader {}))\n  ([ctx reader opts]\n   (let [v (parser/parse-next ctx reader opts)]\n     (if (utils/kw-identical? parser/eof v)\n       (or (get opts :eof)\n           ::eof)\n       v))))\n\n(defn eval-form\n  \"Evaluates form (as produced by `parse-string` or `parse-next`) in the\n  context of `ctx` (as produced with `init`). To allow namespace\n  switches, establish root binding of `sci/ns` with `sci/binding` or\n  `sci/with-bindings.`\"\n  [ctx form]\n  (let [ctx (assoc ctx :id (or (:id ctx) (gensym)))]\n    (i/eval-form ctx form)))\n\n;;;; Scratch\n\n(comment\n  (eval-string \"(inc x)\" {:bindings {'x 2}})\n  )\n"]}