shadow$provide.module$node_modules$vega_regression$build$vega_regression=function(global$jscomp$0,require,module,exports$jscomp$0){(function(global,factory){"object"===typeof exports$jscomp$0&&"undefined"!==typeof module?factory(exports$jscomp$0,require("module$node_modules$vega_statistics$build$vega_statistics"),require("module$node_modules$vega_dataflow$build$vega_dataflow"),require("module$node_modules$vega_util$build$vega_util")):"function"===typeof define&&define.amd?define(["exports","vega-statistics",
"vega-dataflow","vega-util"],factory):(global="undefined"!==typeof globalThis?globalThis:global||self,factory(global.vega={},global.vega,global.vega,global.vega))})(this,function(exports,vegaStatistics,vegaDataflow,vegaUtil){function partition(data,groupby){var groups=[],get=function(f){return f(t)},n;if(null==groupby)groups.push(data);else{var map={};var i=0;for(n=data.length;i<n;++i){var t=data[i];var k=groupby.map(get);var g=map[k];g||(map[k]=g=[],g.dims=k,groups.push(g));g.push(t)}}return groups}
function Loess(params){vegaDataflow.Transform.call(this,null,params)}function Regression(params){vegaDataflow.Transform.call(this,null,params)}Loess.Definition={type:"Loess",metadata:{generates:!0},params:[{name:"x",type:"field",required:!0},{name:"y",type:"field",required:!0},{name:"groupby",type:"field",array:!0},{name:"bandwidth",type:"number","default":.3},{name:"as",type:"string",array:!0}]};vegaUtil.inherits(Loess,vegaDataflow.Transform,{transform:function(_,pulse){var out=pulse.fork(pulse.NO_SOURCE|
pulse.NO_FIELDS);if(!this.value||pulse.changed()||_.modified()){pulse=pulse.materialize(pulse.SOURCE).source;pulse=partition(pulse,_.groupby);var names=(_.groupby||[]).map(vegaUtil.accessorName),m=names.length,as=_.as||[vegaUtil.accessorName(_.x),vegaUtil.accessorName(_.y)],values=[];pulse.forEach(function(g){vegaStatistics.regressionLoess(g,_.x,_.y,_.bandwidth||.3).forEach(function(p){for(var t={},i=0;i<m;++i)t[names[i]]=g.dims[i];t[as[0]]=p[0];t[as[1]]=p[1];values.push(vegaDataflow.ingest(t))})});
this.value&&(out.rem=this.value);this.value=out.add=out.source=values}return out}});var Methods={linear:vegaStatistics.regressionLinear,log:vegaStatistics.regressionLog,exp:vegaStatistics.regressionExp,pow:vegaStatistics.regressionPow,quad:vegaStatistics.regressionQuad,poly:vegaStatistics.regressionPoly};Regression.Definition={type:"Regression",metadata:{generates:!0},params:[{name:"x",type:"field",required:!0},{name:"y",type:"field",required:!0},{name:"groupby",type:"field",array:!0},{name:"method",
type:"string","default":"linear",values:Object.keys(Methods)},{name:"order",type:"number","default":3},{name:"extent",type:"number",array:!0,length:2},{name:"params",type:"boolean","default":!1},{name:"as",type:"string",array:!0}]};vegaUtil.inherits(Regression,vegaDataflow.Transform,{transform:function(_,pulse){var out=pulse.fork(pulse.NO_SOURCE|pulse.NO_FIELDS);if(!this.value||pulse.changed()||_.modified()){var source=pulse.materialize(pulse.SOURCE).source;source=partition(source,_.groupby);var names=
(_.groupby||[]).map(vegaUtil.accessorName),method=_.method||"linear",order=_.order||3,dof="poly"===method?order:"quad"===method?2:1,as=_.as||[vegaUtil.accessorName(_.x),vegaUtil.accessorName(_.y)],fit=Methods[method],values=[],domain=_.extent;vegaUtil.hasOwnProperty(Methods,method)||vegaUtil.error("Invalid regression method: "+method);null!=domain&&"log"===method&&0>=domain[0]&&(pulse.dataflow.warn("Ignoring extent with values \x3c\x3d 0 for log regression."),domain=null);source.forEach(function(g){if(g.length<=
dof)pulse.dataflow.warn("Skipping regression with more parameters than data points.");else{var model=fit(g,_.x,_.y,order);if(_.params)values.push(vegaDataflow.ingest({keys:g.dims,coef:model.coef,rSquared:model.rSquared}));else{var dom=domain||vegaUtil.extent(g,_.x),add=function(p){for(var t={},i=0;i<names.length;++i)t[names[i]]=g.dims[i];t[as[0]]=p[0];t[as[1]]=p[1];values.push(vegaDataflow.ingest(t))};"linear"===method?dom.forEach(function(x){return add([x,model.predict(x)])}):vegaStatistics.sampleCurve(model.predict,
dom,25,200).forEach(add)}}});this.value&&(out.rem=this.value);this.value=out.add=out.source=values}return out}});exports.loess=Loess;exports.regression=Regression;Object.defineProperty(exports,"__esModule",{value:!0})})}
//# sourceMappingURL=module$node_modules$vega_regression$build$vega_regression.js.map
