shadow$provide.module$node_modules$vega_crossfilter$build$vega_crossfilter=function(global$jscomp$0,require,module,exports$jscomp$0){(function(global,factory){"object"===typeof exports$jscomp$0&&"undefined"!==typeof module?factory(exports$jscomp$0,require("module$node_modules$d3_array$dist$d3_array"),require("module$node_modules$vega_dataflow$build$vega_dataflow"),require("module$node_modules$vega_util$build$vega_util")):"function"===typeof define&&define.amd?define(["exports","d3-array","vega-dataflow",
"vega-util"],factory):(global="undefined"!==typeof globalThis?globalThis:global||self,factory((global.vega=global.vega||{},global.vega.transforms={}),global.d3,global.vega,global.vega))})(this,function(exports,d3Array,vegaDataflow,vegaUtil){function Bitmaps(){var width=8,data=[],seen=array32(0),curr=array$jscomp$0(0,width),prev=array$jscomp$0(0,width);return{data:function(){return data},seen:function(){var JSCompiler_inline_result=seen;var length=data.length;JSCompiler_inline_result.length>=length||
(length=new JSCompiler_inline_result.constructor(length),length.set(JSCompiler_inline_result),JSCompiler_inline_result=length);return seen=JSCompiler_inline_result},add:function(array){for(var i=0,j=data.length,n=array.length,t;i<n;++i)t=array[i],t._index=j++,data.push(t)},remove:function(num,map){var n=data.length;num=Array(n-num);var reindex=data,i,j;for(i=0;!map[i]&&i<n;++i)num[i]=data[i],reindex[i]=i;for(j=i;i<n;++i){var t=data[i];map[i]?reindex[i]=-1:(reindex[i]=j,curr[j]=curr[i],prev[j]=prev[i],
num[j]=t,t._index=j++);curr[i]=0}data=num;return reindex},size:function(){return data.length},curr:function(){return curr},prev:function(){return prev},reset:function(k){return prev[k]=curr[k]},all:function(){return 257>width?255:65537>width?65535:4294967295},set:function(k,one){curr[k]|=one},clear:function(k,one){curr[k]&=~one},resize:function(n,m){if(n>curr.length||m>width)width=Math.max(m,width),curr=array$jscomp$0(n,width,curr),prev=array$jscomp$0(n,width)}}}function array$jscomp$0(n,m,array){n=
(257>m?array8:65537>m?array16:array32)(n);array&&n.set(array);return n}function Dimension(index,i$jscomp$0,query){var bit=1<<i$jscomp$0;return{one:bit,zero:~bit,range:query.slice(),bisect:index.bisect,index:index.index,size:index.size,onAdd:function(added,curr){var range=this.bisect(this.range,added.value);added=added.index;var lo=range[0];range=range[1];var n1=added.length,i;for(i=0;i<lo;++i)curr[added[i]]|=bit;for(i=range;i<n1;++i)curr[added[i]]|=bit;return this}}}function SortedIndex(){var index$jscomp$0=
array32(0),value$jscomp$0=[],size=0;return{insert:function(key,data,base){if(!data.length)return[];var n0=size,n1=data.length,addi=array32(n1),addv=Array(n1),i;for(i=0;i<n1;++i)addv[i]=key(data[i]),addi[i]=i;addv=sort(addv,addi);if(n0){key=value$jscomp$0;data=index$jscomp$0;value$jscomp$0=Array(n0+n1);index$jscomp$0=array32(n0+n1);i=addv;var value=value$jscomp$0,index=index$jscomp$0,i0=0,i1=0,i$jscomp$0;for(i$jscomp$0=0;i0<n0&&i1<n1;++i$jscomp$0)key[i0]<i[i1]?(value[i$jscomp$0]=key[i0],index[i$jscomp$0]=
data[i0++]):(value[i$jscomp$0]=i[i1],index[i$jscomp$0]=addi[i1++]+base);for(;i0<n0;++i0,++i$jscomp$0)value[i$jscomp$0]=key[i0],index[i$jscomp$0]=data[i0];for(;i1<n1;++i1,++i$jscomp$0)value[i$jscomp$0]=i[i1],index[i$jscomp$0]=addi[i1]+base}else{if(0<base)for(i=0;i<n1;++i)addi[i]+=base;value$jscomp$0=addv;index$jscomp$0=addi}size=n0+n1;return{index:addi,value:addv}},remove:function(num,map){var n=size,idx,i,j;for(i=0;!map[index$jscomp$0[i]]&&i<n;++i);for(j=i;i<n;++i)map[idx=index$jscomp$0[i]]||(index$jscomp$0[j]=
idx,value$jscomp$0[j]=value$jscomp$0[i],++j);size=n-num},bisect:function(range,array){if(array)var n=array.length;else array=value$jscomp$0,n=size;return[d3Array.bisectLeft(array,range[0],0,n),d3Array.bisectRight(array,range[1],0,n)]},reindex:function(map){for(var i=0,n=size;i<n;++i)index$jscomp$0[i]=map[index$jscomp$0[i]]},index:function(){return index$jscomp$0},size:function(){return size}}}function sort(values,index){values.sort.call(index,function(a,b){a=values[a];b=values[b];return a<b?-1:a>
b?1:0});return d3Array.permute(values,index)}function CrossFilter(params){vegaDataflow.Transform.call(this,Bitmaps(),params);this._dims=this._indices=null}function ResolveFilter(params){vegaDataflow.Transform.call(this,null,params)}var array8=function(n){return new Uint8Array(n)},array16=function(n){return new Uint16Array(n)},array32=function(n){return new Uint32Array(n)};CrossFilter.Definition={type:"CrossFilter",metadata:{},params:[{name:"fields",type:"field",array:!0,required:!0},{name:"query",
type:"array",array:!0,required:!0,content:{type:"number",array:!0,length:2}}]};vegaUtil.inherits(CrossFilter,vegaDataflow.Transform,{transform:function(_,pulse){return this._dims?_.modified("fields")||_.fields.some(function(f){return pulse.modified(f.fields)})?this.reinit(_,pulse):this.eval(_,pulse):this.init(_,pulse)},init:function(_,pulse){for(var fields=_.fields,query=_.query,indices=this._indices={},dims=this._dims=[],m=query.length,i=0,key;i<m;++i)key=fields[i].fname,key=indices[key]||(indices[key]=
SortedIndex()),dims.push(Dimension(key,i,query[i]));return this.eval(_,pulse)},reinit:function(_,pulse){var output=pulse.materialize().fork(),fields=_.fields,query=_.query,indices=this._indices,dims=this._dims,bits=this.value,curr=bits.curr(),prev=bits.prev(),all=bits.all(),out=output.rem=output.add,mod=output.mod,m=query.length,adds={},index,key,remMap;prev.set(curr);pulse.rem.length&&(remMap=this.remove(_,pulse,output));pulse.add.length&&bits.add(pulse.add);if(pulse.mod.length){var modMap={};var add=
pulse.mod;var i=0;for(key=add.length;i<key;++i)modMap[add[i]._index]=1}for(i=0;i<m;++i){var f=fields[i];if(!dims[i]||_.modified("fields",i)||pulse.modified(f.fields))key=f.fname,(add=adds[key])||(indices[key]=index=SortedIndex(),adds[key]=add=index.insert(f,pulse.source,0)),dims[i]=Dimension(index,i,query[i]).onAdd(add,curr)}i=0;for(key=bits.data().length;i<key;++i)remMap[i]||(prev[i]!==curr[i]?out.push(i):modMap[i]&&curr[i]!==all&&mod.push(i));bits.mask=(1<<m)-1;return output},eval:function(_,pulse){var output=
pulse.materialize().fork(),m=this._dims.length,mask=0;pulse.rem.length&&(this.remove(_,pulse,output),mask|=(1<<m)-1);_.modified("query")&&!_.modified("fields")&&(mask|=this.update(_,pulse,output));pulse.add.length&&(this.insert(_,pulse,output),mask|=(1<<m)-1);pulse.mod.length&&(this.modify(pulse,output),mask|=(1<<m)-1);this.value.mask=mask;return output},insert:function(_,pulse,output){pulse=pulse.add;var bits=this.value,dims=this._dims,indices=this._indices;_=_.fields;var adds={};output=output.add;
var n=bits.size()+pulse.length,m=dims.length,k=bits.size();bits.resize(n,m);bits.add(pulse);var curr=bits.curr(),prev=bits.prev(),all=bits.all();for(bits=0;bits<m;++bits){var key=_[bits].fname;key=adds[key]||(adds[key]=indices[key].insert(_[bits],pulse,k));dims[bits].onAdd(key,curr)}for(;k<n;++k)prev[k]=all,curr[k]!==all&&output.push(k)},modify:function(pulse,output){output=output.mod;var bits=this.value,curr=bits.curr();bits=bits.all();pulse=pulse.mod;var n;var i=0;for(n=pulse.length;i<n;++i){var k=
pulse[i]._index;curr[k]!==bits&&output.push(k)}},remove:function(_,pulse,output){_=this._indices;var bits=this.value,curr=bits.curr(),prev=bits.prev();bits=bits.all();var map={};output=output.rem;var tuples=pulse.rem,n,f;var i=0;for(n=tuples.length;i<n;++i){var k=tuples[i]._index;map[k]=1;prev[k]=f=curr[k];curr[k]=bits;f!==bits&&output.push(k)}for(k in _)_[k].remove(n,map);this.reindex(pulse,n,map);return map},reindex:function(pulse,num,map){var indices=this._indices,bits=this.value;pulse.runAfter(function(){var indexMap=
bits.remove(num,map),key;for(key in indices)indices[key].reindex(indexMap)})},update:function(_,pulse,output){var dims=this._dims,query=_.query;pulse=pulse.stamp;var m=dims.length,mask=0,q;for(q=output.filters=0;q<m;++q)if(_.modified("query",q)){var i=q;++mask}if(1===mask)mask=dims[i].one,this.incrementOne(dims[i],query[i],output.add,output.rem);else for(mask=q=0;q<m;++q)_.modified("query",q)&&(mask|=dims[q].one,this.incrementAll(dims[q],query[q],pulse,output.add),output.rem=output.add);return mask},
incrementAll:function(dim,query,stamp,out){var bits=this.value,seen=bits.seen(),curr=bits.curr();bits=bits.prev();var index=dim.index(),old=dim.bisect(dim.range),range=dim.bisect(query),lo1=range[0];range=range[1];var lo0=old[0];old=old[1];var one=dim.one,j;if(lo1<lo0){var i=lo1;for(j=Math.min(lo0,range);i<j;++i){var k=index[i];seen[k]!==stamp&&(bits[k]=curr[k],seen[k]=stamp,out.push(k));curr[k]^=one}}else if(lo1>lo0)for(i=lo0,j=Math.min(lo1,old);i<j;++i)k=index[i],seen[k]!==stamp&&(bits[k]=curr[k],
seen[k]=stamp,out.push(k)),curr[k]^=one;if(range>old)for(i=Math.max(lo1,old),j=range;i<j;++i)k=index[i],seen[k]!==stamp&&(bits[k]=curr[k],seen[k]=stamp,out.push(k)),curr[k]^=one;else if(range<old)for(i=Math.max(lo0,range),j=old;i<j;++i)k=index[i],seen[k]!==stamp&&(bits[k]=curr[k],seen[k]=stamp,out.push(k)),curr[k]^=one;dim.range=query.slice()},incrementOne:function(dim,query,add,rem){var curr=this.value.curr(),index=dim.index(),old=dim.bisect(dim.range),range=dim.bisect(query),lo1=range[0];range=
range[1];var lo0=old[0];old=old[1];var one=dim.one,j;if(lo1<lo0){var i=lo1;for(j=Math.min(lo0,range);i<j;++i){var k=index[i];curr[k]^=one;add.push(k)}}else if(lo1>lo0)for(i=lo0,j=Math.min(lo1,old);i<j;++i)k=index[i],curr[k]^=one,rem.push(k);if(range>old)for(i=Math.max(lo1,old),j=range;i<j;++i)k=index[i],curr[k]^=one,add.push(k);else if(range<old)for(i=Math.max(lo0,range),j=old;i<j;++i)k=index[i],curr[k]^=one,rem.push(k);dim.range=query.slice()}});ResolveFilter.Definition={type:"ResolveFilter",metadata:{},
params:[{name:"ignore",type:"number",required:!0,description:"A bit mask indicating which filters to ignore."},{name:"filter",type:"object",required:!0,description:"Per-tuple filter bitmaps from a CrossFilter transform."}]};vegaUtil.inherits(ResolveFilter,vegaDataflow.Transform,{transform:function(_,pulse){var ignore=~(_.ignore||0);_=_.filter;var mask=_.mask;if(0===(mask&ignore))return pulse.StopPropagation;pulse=pulse.fork(pulse.ALL);var data=_.data(),curr=_.curr(),prev=_.prev(),pass=function(k){return curr[k]&
ignore?null:data[k]};pulse.filter(pulse.MOD,pass);mask&mask-1?(pulse.filter(pulse.ADD,function(k){var c=curr[k]&ignore;return!c&&c^prev[k]&ignore?data[k]:null}),pulse.filter(pulse.REM,function(k){var c=curr[k]&ignore;return!c||c^c^prev[k]&ignore?null:data[k]})):(pulse.filter(pulse.ADD,pass),pulse.filter(pulse.REM,function(k){return(curr[k]&ignore)===mask?data[k]:null}));return pulse.filter(pulse.SOURCE,function(t){return pass(t._index)})}});exports.crossfilter=CrossFilter;exports.resolvefilter=ResolveFilter;
Object.defineProperty(exports,"__esModule",{value:!0})})}
//# sourceMappingURL=module$node_modules$vega_crossfilter$build$vega_crossfilter.js.map
