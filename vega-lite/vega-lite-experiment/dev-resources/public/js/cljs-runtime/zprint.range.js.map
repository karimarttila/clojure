{"version":3,"sources":["zprint/range.cljc"],"mappings":"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","names":["zprint.range/in-row?","n","row","zprint.range/row-before?","row-a","row-b","zprint.range/between-rows?","linenumber","cljs.core/map?","zprint.range/scan-for-row","row-vec","row-vec-index","max-tries","current-index","previous-index","tries","cljs.core.get","row-or-direction","next-index","next-row","zprint.range/abs","var_args","G__59664","zprint.range/find-row","js/Error","dbg?","scan-size","cljs.core.println","size","cljs.core/count","maybe-index","cljs.core._EQ_","G__59673","G__59674","fexpr__59672","cljs.core/-","cljs.core/+","zprint.range.find_row","zprint.range/next-non-blank-line","line-vec","index","max-idx","idx","line","cljs.core.nth","cljs.core/empty?","clojure.string/trim","zprint.range/previous-non-blank-line","zprint.range/expand-range-to-top-level","filestring","lines","start","end","line-count","e59676","cljs.core.mapv","cljs.core/meta","edamame.core.parse_string_all","expr","cljs.core/with-meta","cljs.core/*ns*","e","cljs.core.into","cljs.core.remove","cljs.core/nil?","_","cljs.core.prn","start-row-idx","x__4214__auto__","y__4215__auto__","actual-start","end-row-idx","actual-end","end-row","zprint.range/split-out-range","before","range","after","cljs.core.take","cljs.core.drop","zprint.range/reassemble-range","before-lines","after-lines","before?","clojure.string.join","range?","after?","before-range","range-after"],"sourcesContent":["(ns ^:no-doc zprint.range\n  (:require [clojure.string :as s]\n            [edamame.core :refer [parse-string-all]]))\n\n;;\n;; # Handle range specification\n;;\n\n(defn in-row?\n  \"If a line number n is in a particular edamame row, return the row map.\n  If it is not in the row, return +1 or -1 to indicate which direction\n  to look.\"\n  [n row]\n  #_(println \"n:\" n \"row:\" row)\n  (when row\n    (if (<= (:row row) n (:end-row row)) row (if (< n (:row row)) -1 +1))))\n\n(defn row-before?\n  \"Given two rows, is the first before the second?\"\n  [row-a row-b]\n  #_(println \"row-before? row-a:\" row-a \"row-b:\" row-b)\n  (< (:end-row row-a) (:row row-b)))\n\n(defn between-rows?\n  \"Given two rows, if the linenumber is between the rows, return true, else\n  nil.\"\n  [linenumber row-a row-b]\n  #_(println \"between-rows? linenumber:\" linenumber\n             \"row-a:\" row-a\n             \"row-b:\" row-b)\n  (when (and (map? row-a) (map? row-b))\n    (if (row-before? row-a row-b)\n      (< (:end-row row-a) linenumber (:row row-b))\n      (< (:end-row row-b) linenumber (:row row-a)))))\n\n(defn scan-for-row\n  \"Given a row-vec, and a current index into the row-vec, if the\n  linenumber is within that row, return the index to that row.   If\n  the linenumber is not in that row, then scan either way for\n  max-tries looking for a match for this linenumber.  Return the\n  row index if a row is found containing this linenumber. If it is\n  between two rows, return the row after.  If we fall off the either\n  end of the row-vec, then return :before-beginning or :beyone-end.  \n  If we don't find anything after trying for max-tries, :before or\n  :after, depending on which way we should try next.\"\n  [row-vec row-vec-index linenumber max-tries]\n  (loop [current-index row-vec-index\n         previous-index nil\n         tries 0]\n    (let [row (get row-vec current-index)\n          row-or-direction (in-row? linenumber row)]\n      #_(println \"scan-for-row current-index:\" current-index\n                 \"previous-index:\" previous-index\n                 \"tries:\" tries\n                 \"row:\" row\n                 \"row-or-direction\" row-or-direction)\n      (cond (map? row-or-direction) current-index   ; in this row\n            (nil? row-or-direction)\n              (if (pos? current-index) :beyond-end :before-beginning)\n            :else\n              (if (>= tries max-tries)\n                ; tell caller where to look next\n                (if (pos? row-or-direction) :after :before)\n                (let [next-index (+ current-index row-or-direction)\n                      next-row (get row-vec next-index)\n                      row-or-direction (in-row? linenumber next-row)]\n                  (cond (map? row-or-direction) next-index ; we are in the row,\n                                                           ; return its index\n                        (nil? row-or-direction)\n                          (if (pos? next-index) :beyond-end :before-beginning)\n                        :else (if (between-rows? linenumber row next-row)\n                                ; We are between rows, return later one\n                                (if (row-before? row next-row)\n                                  next-index\n                                  current-index)\n                                ; Keep looking\n                                (recur (+ current-index row-or-direction)\n                                       current-index\n                                       (inc tries))))))))))\n\n(defn abs \"Return the absolute value of a number.\" [n] (if (neg? n) (- n) n))\n\n(defn find-row\n  \"Given a vector of rows, find the row that contains a line number,\n  linenumber, and return the number of that row in the vector.\n  row-vec looks like this: \n  [{:row 2, :col 1, :end-row 7, :end-col 21}\n   {:row 9, :col 1, :end-row 18, :end-col 6} \n   {:row 20, :col 1, :end-row 29, :end-col 6}]\n  If none exists, return the next row. Note that line numbers are 1\n  based, not zero based for this routine and the information in\n  row-vec, but the index into row-vec that this routine returns is\n  zero based.  Uses a binary search. If the line number is before the\n  first information in the row-vec, returns :before-beginning, and\n  if it is after the last information in the row-vec, returns\n  :beyond-end. Note that the row-vec as returned from edamame\n  parse-string-all contains not only maps like {:row 5 :end-row 10}\n  but also nils for things that didn't have paired delimiters around\n  them (e.g., keywords, strings, etc.).  You must remove those\n  from row-vec before calling find-row.  Note that find-row returns an \n  index into row-vec, and it must be the row-vec that has had nils \n  removed from it (or this routine would do that for you).\"\n  ([row-vec linenumber dbg? scan-size]\n   (when dbg?\n     (println \"find-row: linenumber:\" linenumber \"scan-size:\" scan-size))\n   (let [size (count row-vec)]\n     ; We are 1 based, because edamame row numbers are 1 based.\n     (loop [row-vec-index (int (/ size 2))\n            previous-index 0\n            tries 0]\n       #_(println \"\\n\\n================== row-vec-index:\" row-vec-index)\n       (if (> tries 10)\n         :fail\n         (let [maybe-index\n                 (scan-for-row row-vec row-vec-index linenumber scan-size)]\n           ; If it is a number, that is the row-vec-index to return\n           ; If it is :before, we ran off the beginning, :after the end\n           ; nil means that we didn't find it, but can keep looking\n           #_(println \"maybe-index:\" maybe-index)\n           (cond\n             (number? maybe-index) maybe-index  ; we found something to return\n             ; is it in this row?\n             (or (= maybe-index :before-beginning) (= maybe-index :beyond-end))\n               maybe-index\n             :else ; Has to be :before or :after\n               (do #_(println \"find-row: maybe-index:\" maybe-index\n                              \"row-vec-index:\" row-vec-index\n                              \"previous-index:\" previous-index\n                              \"abs:\" (abs (- row-vec-index previous-index)))\n                   (recur ((if (= maybe-index :before) - +)\n                            row-vec-index\n                            (int (/ (abs (- row-vec-index previous-index)) 2)))\n                          row-vec-index\n                          (inc tries)))))))))\n  ([row-vec n dbg?] (find-row row-vec n dbg? 4)))\n\n(defn next-non-blank-line\n  \"Given a sequence of lines and a starting line index in that sequence,\n  return the index of the first non-blank line including or after that\n  starting line index.\"\n  [line-vec index]\n  (let [max-idx (dec (count line-vec))]\n    (loop [idx index]\n      (let [line (nth line-vec idx)]\n        ; Return current idx if it is non-blank or the last line\n        (if (or (not (empty? (clojure.string/trim line))) (>= idx max-idx))\n          idx\n          (recur (inc idx)))))))\n\n(defn previous-non-blank-line\n  \"Given a sequence of lines and a starting line index in that sequence,\n  return the index of the first previous non-blank line including or before\n  that starting line index.  Returns -1 if no non-blank line found.\"\n  [line-vec index]\n  (loop [idx index]\n    (let [line (nth line-vec idx)]\n      ; Return current idx if it is non-blank\n      (cond (not (empty? (clojure.string/trim line))) idx\n            ; if the first line is not non-blank, then we didn't find one\n            (zero? idx) -1\n            ; keep looking for a non-blank line\n            :else (recur (dec idx))))))\n\n(defn expand-range-to-top-level\n  \"Given a string which contains lines and a vector of those lines,\n  and a range of lines inside of them, expand the range such that\n  it covers everything from the first non-blank line beyond the\n  previous top level expression before the start to the end of the\n  top level expression containing the end of the range.  Returns\n  [actual-start actual-end].  Note that start, end, actual-start\n  and actual-end are all zero based line numbers.\"\n  ; But also note that parse-string-all (and thus row-vec) and\n  ; find-row all operate with one-based line numbers!!!\n  [filestring lines start end dbg?]\n  (when dbg? (println \"expand-range-to-top-level: start:\" start \"end:\" end))\n  (let [line-count (count lines)\n        start (if (number? start) start 0)\n        end (if (number? end) end line-count)\n        ; If end is before start, make them the same\n        end (if (< end start) start end)\n        ; Get a vector of maps describing all top level expressions using\n        ; one based line numbers.  For example:\n        ; [{:col 1, :end-col 21, :end-row 7, :row 2}\n        ;  {:col 1, :end-col 6, :end-row 20, :row 11}\n        ;  {:col 1, :end-col 70, :end-row 26, :row 22}\n        ;  {:col 1, :end-col 48, :end-row 29, :row 27}]\n        row-vec (try (mapv meta\n                       (parse-string-all\n                         filestring\n                         {:all true,\n                          :features #{:clj :cljs},\n                          ; Ensure that reader-conditionals have something\n                          ; show up with meta data regardless of the\n                          ; \"features\" in the reader-conditional\n                          :read-cond (fn [expr] (with-meta [] (meta expr))),\n                          :auto-resolve {:current *ns*}}))\n                     ; If we can't parse it, we have set row-vec to nil, which\n                     ; should cause us to format everything.\n                     (catch #?(:clj Exception\n                               :cljs :default)\n                       e\n                       nil))\n        row-vec (when row-vec (into [] (remove nil? row-vec)))\n        ; If row-vec is nil, then we didn't parse this, so do everything\n        ; silently.\n        _ (when dbg? (prn row-vec))\n        ; Figure out which expression start falls within, after making\n        ; it a one-based line number.  -idx are indexes into row-vec,\n        ; *not* linenumbers\n        start-row-idx (if row-vec (find-row row-vec (inc start) dbg?) :fail)\n        _ (when dbg?\n            (println \"expand-range-to-top-level start-row-idx:\"\n                     start-row-idx\n                     (if (number? start-row-idx)\n                       (str \"row:\" (nth row-vec start-row-idx)\n                            \"previous row:\" (nth row-vec\n                                                 (max 0 (dec start-row-idx))))\n                       \"\")))\n        actual-start\n          ; -1 is a signal to not start at the beginning unless the end is\n          ; also -1, in which case it is a signal to put everything in the\n          ; before\n          (cond (= start-row-idx :fail) -1\n                (and (= start-row-idx :before-beginning) (not (neg? start))) 0\n                (= start-row-idx :before-beginning) -1\n                (= start-row-idx 0) 0\n                (= start-row-idx :beyond-end) line-count\n                ; normal case -- the line beyond the previous form\n                ; where (dec start-row-idx) is presumably the previous form\n                :else (:end-row (get row-vec (dec start-row-idx))))\n        ; Now, move actual-start to the first non-blank line after or equal to\n        ; actual-start.  But not if it is zero or negative, since we don't\n        ; want to mess with the range if it encompasses the beginning of\n        ; the file.\n        actual-start (if (or (< actual-start 1) (>= actual-start line-count))\n                       actual-start\n                       (next-non-blank-line lines actual-start))\n        end-row-idx (if row-vec (find-row row-vec (inc end) dbg?) :fail)\n        _ (when dbg?\n            (println \"expand-range-to-top-level end-row-idx:\"\n                     end-row-idx\n                     (if (number? end-row-idx)\n                       (str \"row:\" (nth row-vec end-row-idx))\n                       \"\")))\n        actual-end (cond\n                     (or (= end-row-idx :fail) (= end-row-idx :beyond-end))\n                       ; We are beyond the end or it didn't parse, say the\n                       ; end is beyond the last line.\n                       line-count\n                     (= end-row-idx :before-beginning)\n                       ; Someone is confused here too, say the end is the\n                       ; start.\n                       :do-nothing\n                     :else (let [end-row (get row-vec end-row-idx)]\n                             ; end-row-idx is either the row in which end falls\n                             ; or the next row if it was between rows\n                             ; Note: :row is the start line of a row-map\n                             ;\n                             ; Does end fall between two top-level expressions?\n                             (if (< (inc end) (:row end-row))\n                               ; Yes -- are start and end in same gap\n                               ; between expressions?\n                               (if (= end-row-idx start-row-idx)\n                                 ; Yes, do nothing\n                                 :do-nothing\n                                 ; No, work backward to the first non-blank\n                                 ; line prior to the end\n                                 (previous-non-blank-line lines end))\n                               ; No, end falls inside of an expression, so use\n                               ; the end of that expression.  Make it zero\n                               ; based.\n                               (dec (:end-row end-row)))))\n        actual-start (if (= actual-end :do-nothing) -1 actual-start)\n        actual-end (if (= actual-end :do-nothing) -1 actual-end)]\n    [actual-start actual-end]))\n\n;;\n;; # Take apart a series of lines based on a range\n;;\n\n(defn split-out-range\n  \"Given lines, a sequence of lines, and a start and end of a range,\n  split the sequence of lines into three parts: [before-lines range\n  after-lines].  If any of these collections would be empty, return\n  an empty sequence. End must be equal to or greater than start. If\n  end is neg?, there will be no range.\"\n  [lines start end]\n  (let [start (max start 0)\n        before start\n        range (if (neg? end) 0 (inc (- end start)))\n        after (- (dec (count lines)) end)]\n    #_(println \"before:\" before \"range:\" range \"after:\" after)\n    [(take before lines) (take range (drop before lines))\n     (take after (drop (+ before range) lines))]))\n\n(defn reassemble-range\n  \"Given before-lines, range, and after-lines where before-lines\n  and after-lines are sequences of lines, and range is a string\n  which has been formatted, reassemble these three chunks into a\n  single string with appropriate newlines joining them together.\n  Note that this is *not* an inverse to split-out-range, because\n  in that routine range is a seq of lines, and in this routine\n  range is a string.  Note also that we only join them with a \n  newline if there are two pieces, otherwise we get extra lines.\"\n  [before-lines range after-lines]\n  (let [before? (not (empty? before-lines))\n        before-lines (if before? (clojure.string/join \"\\n\" before-lines) \"\")\n        range? (not (empty? range))\n        after? (not (empty? after-lines))\n        after-lines (if after? (clojure.string/join \"\\n\" after-lines) \"\")\n        before-range (if (and before? range?) \"\\n\" \"\")\n        range-after (if (and range? after?) \"\\n\" \"\")\n        range-after (if (and (not range?) before? after?) \"\\n\" range-after)]\n    (str before-lines before-range range range-after after-lines)))\n\n"]}