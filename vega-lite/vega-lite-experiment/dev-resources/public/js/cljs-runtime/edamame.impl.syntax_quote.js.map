{"version":3,"sources":["edamame/impl/syntax_quote.cljc"],"mappings":"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","names":["edamame.impl.syntax-quote/unquote?","form","cljs.core/seq?","cljs.core._EQ_","cljs.core/first","edamame.impl.syntax-quote/unquote-splicing?","edamame.impl.syntax-quote/expand-list","ctx","reader","s","cljs.core/seq","r","cljs.core/transient","item","ret","cljs.core.conj_BANG_","cljs.core/List","cljs.core/second","edamame.impl.syntax-quote/syntax-quote","cljs.core/next","cljs.core/persistent!","edamame.impl.syntax-quote/syntax-quote-coll","type","coll","res","cljs.core/cons","edamame.impl.syntax-quote/map-func","cljs.core/count","edamame.impl.syntax-quote/flatten-map","key-vals","e","cljs.core/key","cljs.core/val","p__59179","map__59180","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply","cljs.core/hash-map","gensyms","cljs.core.get","edamame.impl.syntax-quote/syntax-quote*","cljs.core/special-symbol?","cljs.core/Symbol","sym-name","cljs.core/name","clojure.string/ends-with?","temp__5733__auto__","generated","cljs.core/deref","n","cljs.core.subs","cljs.core.gensym","cljs.core.symbol","cljs.core.swap_BANG_","cljs.core/assoc","f","fexpr__59186","or__4126__auto__","cljs.core/identity","js/Error","cljs.core/coll?","cljs.core/IRecord","cljs.core/map?","cljs.core/vector?","cljs.core/set?","cljs.core/list?","seq","cljs.core/Keyword","cljs.core/char?","cljs.core/boolean?","cljs.core/regexp?","edamame.impl.syntax-quote/add-meta","cljs.core.dissoc","cljs.core/meta"],"sourcesContent":["(ns edamame.impl.syntax-quote\n  \"Taken and adapted from\n  https://github.com/clojure/tools.reader/blob/master/src/main/clojure/clojure/tools/reader.clj\"\n  {:no-doc true}\n  (:require [clojure.string :as str]))\n\n(defn unquote? [form]\n  (and (seq? form)\n       (= (first form) 'clojure.core/unquote)))\n\n(defn- unquote-splicing? [form]\n  (and (seq? form)\n       (= (first form) 'clojure.core/unquote-splicing)))\n\n(declare syntax-quote)\n\n(defn- expand-list\n  \"Expand a list by resolving its syntax quotes and unquotes\"\n  [ctx #?(:cljs ^not-native reader :default reader) s]\n  (loop [s (seq s) r (transient [])]\n    (if s\n      (let [item (first s)\n            ret (conj! r\n                       (cond\n                         (unquote? item)          (list 'clojure.core/list (second item))\n                         (unquote-splicing? item) (second item)\n                         :else                    (list 'clojure.core/list (syntax-quote ctx reader item))))]\n        (recur (next s) ret))\n      (seq (persistent! r)))))\n\n(defn- syntax-quote-coll [ctx #?(:cljs ^not-native reader :default reader) type coll]\n  ;; We use sequence rather than seq here to fix http://dev.clojure.org/jira/browse/CLJ-1444\n  ;; But because of http://dev.clojure.org/jira/browse/CLJ-1586 we still need to call seq on the form\n  (let [res (list 'clojure.core/sequence\n                  (list 'clojure.core/seq\n                        (cons 'clojure.core/concat\n                              (expand-list ctx reader coll))))]\n    (if type\n      (list 'clojure.core/apply type res)\n      res)))\n\n(defn map-func\n  \"Decide which map type to use, array-map if less than 16 elements\"\n  [coll]\n  (if (>= (count coll) 16)\n    'clojure.core/hash-map\n    'clojure.core/array-map))\n\n(defn- flatten-map\n  \"Flatten a map into a seq of alternate keys and values\"\n  [form]\n  (loop [s (seq form) key-vals (transient [])]\n    (if s\n      (let [e (first s)]\n        (recur (next s) (-> key-vals\n                            (conj! (key e))\n                            (conj! (val e)))))\n      (seq (persistent! key-vals)))))\n\n(defn- syntax-quote* [{:keys [:gensyms] :as ctx}\n                     #?(:cljs ^not-native reader :default reader) form]\n  (cond\n    (special-symbol? form) (list 'quote form)\n    (symbol? form)\n    (list 'quote\n          (let [sym-name (name form)]\n            (cond (special-symbol? form) form\n                  (str/ends-with? sym-name \"#\")\n                  (if-let [generated (get @gensyms form)]\n                    generated\n                    (let [n (subs sym-name 0 (dec (count sym-name)))\n                          generated (gensym (str n \"__\"))\n                          generated (symbol (str (name generated) \"__auto__\"))]\n                      (swap! gensyms assoc form generated)\n                      generated))\n                  :else\n                  (let [f (-> ctx :syntax-quote :resolve-symbol)]\n                    ((or f identity) form)))))\n    (unquote? form) (second form)\n    (unquote-splicing? form) (throw (new #?(:cljs js/Error :clj IllegalStateException)\n                                         \"unquote-splice not in list\"))\n\n    (coll? form)\n    (cond\n      (instance? #?(:clj clojure.lang.IRecord :cljs IRecord) form) form\n      (map? form) (syntax-quote-coll ctx reader (map-func form) (flatten-map form))\n      (vector? form) (list 'clojure.core/vec (syntax-quote-coll ctx reader nil form))\n      (set? form) (syntax-quote-coll ctx reader 'clojure.core/hash-set form)\n      (or (seq? form) (list? form))\n      (let [seq (seq form)]\n        (if seq\n          (syntax-quote-coll ctx reader nil seq)\n          '(clojure.core/list)))\n\n      :else (throw (new #?(:clj UnsupportedOperationException\n                           :cljs js/Error) \"Unknown Collection type\")))\n\n    (or (keyword? form)\n        (number? form)\n        (char? form)\n        (string? form)\n        (nil? form)\n        (boolean? form)\n        #?(:clj (instance? java.util.regex.Pattern form)\n           :cljs (regexp? form)))\n    form\n    :else (list 'quote form)))\n\n(defn- add-meta [ctx reader form ret]\n  (if (and #?(:clj (instance? clojure.lang.IObj form)\n              :cljs (implements? IWithMeta form))\n           (seq (dissoc (meta form) (:row-key ctx) (:col-key ctx) (:end-row-key ctx) (:end-col-key ctx))))\n    (list #?(:clj 'clojure.core/with-meta\n             :cljs 'cljs.core/with-meta) ret (syntax-quote* ctx reader (meta form)))\n    ret))\n\n(defn syntax-quote [ctx reader form]\n  (let [ret (syntax-quote* ctx reader form)]\n    (add-meta ctx reader form ret)))\n"]}