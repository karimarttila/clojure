{"version":3,"sources":["edamame/core.cljc"],"mappings":";AAIA,AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,AAAAA,AAAME;AAAN,AAAA,AAAAD,AAAA,AAAA;AAAA,AAAA,AAAAA;AAAA;AAAA,AAAAC,AAAA,AAAA,AAAA;;;AAAA;AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;;;;AAAA,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA;;;;;AAAA,AAAA,AAAA,AAAMD,AAsDFE;AAtDJ,AAuDG,AAAA,AAACC,AAAeD;;;AAvDnB,AAAA,AAAA,AAAMF,AAwDFE,AAAEE;AAxDN,AAyDG,AAACD,AAAeD,AAAEE;;;AAzDrB,AAAA,AAAA,AAAMJ;;AAAN,AA2DA,AAAA;;;;AAAA,AAAAF,AAAMQ;AAAN,AAAA,AAAAD,AAAA,AAAA;AAAA,AAAA,AAAAA;AAAA;AAAA,AAAAC,AAAA,AAAA,AAAA;;;AAAA;AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;;;;AAAA,AAAA,AAAAL,AAAA,AAAA,AAAA,AAAA;;;;;AAAA,AAAA,AAAA,AAAMK,AAGFJ;AAHJ,AAIG,AAAA,AAACK,AAAmBL;;;AAJvB,AAAA,AAAA,AAAMI,AAKFJ,AAAEE;AALN,AAMG,AAACG,AAAmBL,AAAEE;;;AANzB,AAAA,AAAA,AAAME;;AAAN,AAQA;;;;AAAA,AAAME,AAGHC;AAHH,AAIE,AAACC,AAASD;;AAEZ;;;;AAAA,AAAME,AAGHF;AAHH,AAIE,AAACG,AAAwBH;;AAE3B,AAAA,AAAMI,AAAiBC;AAAvB,AACE,AAACC,AAAkBD;;AAErB,AAAA,AAAME,AAAmBF;AAAzB,AACE,AAACG,AAAoBH;;AAEvB,AAAA,AAAMI,AAAgBd;AAAtB,AACE,AAACe,AAAiBf;;AAEpB,AAAA;;;;AAAA,AAAAN,AAAMuB;AAAN,AAAA,AAAAD,AAAA,AAAA;AAAA,AAAA,AAAAA;AAAA;AAAA,AAAAC,AAAA,AAAA,AAAA;;;AAAA;AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;;;;AAAA,AAAA,AAAApB,AAAA,AAAA,AAAA,AAAA;;;;;AAAA,AAAA,AAAA,AAAMoB,AAGFP;AAHJ,AAGY,AAAA,AAACQ,AAAWR;;;AAHxB,AAAA,AAAA,AAAMO,AAIFP,AAAOV;AAJX,AAKG,AAAMmB,AAAE,AAACC,AAAapB,AAAKU;AAA3B,AACE,AAAI,AAAA,AAA0BW,AAA6CF;AACzE,AAAAG,AAAI,AAAA,AAACC,AAAIvB;AAAT,AAAA,AAAAsB;AAAAA;;AAAA;;;AAEAH;;;;AATP,AAAA,AAAA,AAAMF;;AAAN,AAWA;;;AAAA,AAAMO,AAEHC;AAFH,AAKW,AAAA,AAAA,AAAA,AAAsBA;AAAtB,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAC,AAAA,AAAsBD,AAAAA;AAAtB;;AAAA,AAAA,AAAA,AAAsBA;AAAtB,AAAAE,AAAYC,AAAUH;;AAAtB;;;;AAAA,AAAAE,AAAYC,AAAUH;;;AAIjC","names":["var_args","G__59563","edamame.core/parse-string","js/Error","s","edamame.impl.parser/parse-string","opts","G__59610","edamame.core/parse-string-all","edamame.impl.parser/parse-string-all","edamame.core/reader","x","edamame.impl.parser/reader","edamame.core/source-reader","edamame.impl.parser/source-logging-reader","edamame.core/get-line-number","reader","edamame.impl.parser/get-line-number","edamame.core/get-column-number","edamame.impl.parser/get-column-number","edamame.core/normalize-opts","edamame.impl.parser/normalize-opts","G__59613","edamame.core/parse-next","edamame.core.parse_next","v","edamame.impl.parser.parse_next","cljs.core/keyword-identical?","or__4126__auto__","cljs.core.get","edamame.core/iobj?","obj","cljs.core/PROTOCOL_SENTINEL","cljs.core/native-satisfies?","cljs.core/IWithMeta"],"sourcesContent":["(ns edamame.core\n  (:require\n   [edamame.impl.parser :as p]))\n\n(defn parse-string\n  \"Parses first EDN value from string.\n\n  Supported parsing options:\n\n  `:deref`: parse forms starting with `@`. If `true`, the resulting\n  expression will be parsed as `(deref expr)`.\n\n  `:fn`: parse function literals (`#(inc %)`). If `true`, will be parsed as `(fn [%1] (inc %))`.\n\n  `:quote`: parse quoted expression `'foo`. If `true`, will be parsed as `(quote foo)`.\n\n  `:read-eval`: parse read-eval (`=(+ 1 2 3)`). If `true`, the\n  resulting expression will be parsed as `(read-eval (+ 1 2 3))`.\n\n  `:regex`: parse regex literals (`#\\\"foo\\\"`). If `true`, defaults to\n  `re-pattern`.\n\n  `:syntax-quote`: parse syntax-quote (`(+ 1 2 3)`). Symbols get\n  qualified using `:resolve-symbol` which defaults to `identity`:\n  `(parse-string \\\"`x\\\" {:syntax-quote {:resolve-symbol #(symbol \\\"user\\\" (str %))}})\n  ;;=> (quote user/x)`.\n\n  `:var`: parse var literals (`#'foo`). If `true`, the resulting\n  expression will be parsed as `(var foo)`.\n\n  `:all`: when `true`, the above options will be set to `true` unless\n  explicitly provided.\n\n  Supported options for processing reader conditionals:\n\n  `:read-cond`: - `:allow` to process reader conditionals, or\n                  `:preserve` to keep all branches\n  `:features`: - persistent set of feature keywords for reader conditionals (e.g. `#{:clj}`).\n\n  `:auto-resolve`: map of alias to namespace symbols for\n  auto-resolving keywords. Use `:current` as the alias for the current\n  namespace.\n\n  `:readers`: data readers.\n\n  `:postprocess`: a function that is called with a map containing\n  `:obj`, the read value, and `:loc`, the location metadata. This can\n  be used to handle objects that cannot carry metadata differently. If\n  this option is provided, attaching location metadata is not\n  automatically added to the object.\n\n  `:location?`: a predicate that is called with the parsed\n  object. Should return a truthy value to determine if location\n  information will be added.\n\n  Additional arguments to tools.reader may be passed with\n  `:tools.reader/opts`, like `:readers` for passing reader tag functions.\n  \"\n  ([s]\n   (p/parse-string s nil))\n  ([s opts]\n   (p/parse-string s opts)))\n\n(defn parse-string-all\n  \"Like parse-string but parses all values from string and returns them\n  in a vector.\"\n  ([s]\n   (p/parse-string-all s nil))\n  ([s opts]\n   (p/parse-string-all s opts)))\n\n(defn reader\n  \"Coerces x into indexing pushback-reader to be used with\n  parse-next. Accepts: string or java.io.Reader.\"\n  [x]\n  (p/reader x))\n\n(defn source-reader\n  \"Coerces x into source-logging-reader to be used with\n  parse-next. Accepts: string or java.io.Reader.\"\n  [x]\n  (p/source-logging-reader x))\n\n(defn get-line-number [reader]\n  (p/get-line-number reader))\n\n(defn get-column-number [reader]\n  (p/get-column-number reader))\n\n(defn normalize-opts [opts]\n  (p/normalize-opts opts))\n\n(defn parse-next\n  \"Parses next form from reader. Accepts same opts as parse-string, must\n  be normalized with normalize-opts first.\"\n  ([reader] (parse-next reader {}))\n  ([reader opts]\n   (let [v (p/parse-next opts reader)]\n     (if (#?(:clj identical? :cljs keyword-identical?) :edamame.impl.parser/eof v)\n       (or (get opts :eof)\n           ::eof)\n       v))))\n\n(defn iobj?\n  \"Returns true if obj can carry metadata.\"\n  [obj]\n  #?(:clj\n     (instance? clojure.lang.IObj obj)\n     :cljs (satisfies? IWithMeta obj)))\n\n;;;; Scratch\n\n(comment\n  (parse-string \"(1 2 3 #_4)\"))\n"]}