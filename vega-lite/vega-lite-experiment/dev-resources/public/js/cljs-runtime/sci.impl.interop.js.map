{"version":3,"sources":["sci/impl/interop.cljc"],"mappings":"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","names":["sci.impl.interop/toJS","v","cljs.core/MetaFn","cljs.core/clj->js","sci.impl.interop/js-object-array","args","cljs.core/to-array","cljs.core.map","sci.impl.interop/invoke-instance-method","obj","_target-class","method-name","cljs.core.subs","temp__5733__auto__","method","js/Error","p__49089","vec__49090","cljs.core.nth","sci.impl.interop/get-static-field","class","field-name-sym","clojure.string/includes?","cljs.core.apply","goog.object/getValueByKeys","clojure.string.split","goog.object/get","sci.impl.interop/invoke-js-constructor","constructor","ctor","js/Function.prototype.bind.apply","G__49102","cljs.core.ex_info","sci.impl.interop/invoke-constructor","p__49114","vec__49115","sci.impl.interop/invoke-static-method","field","cljs.core/not","clojure.string/ends-with?","p__49139","map__49140","cljs.core/PROTOCOL_SENTINEL","cljs.core/hash-map","env","cljs.core.get","class->opts","sci.impl.interop/fully-qualify-class","sym","or__4126__auto__","ns*","cljs.core/namespace","cljs.core/contains?","cljs.core.symbol","cljs.core/name","cljs.core/deref","cnn","sci.impl.vars/current-ns-name","cljs.core.get_in","p__49146","map__49147","sci.impl.interop/resolve-class-opts","class-opts","imports","vec__49153","_","cljs.core/find","temp__5735__auto__","sci.impl.interop/resolve-class","ctx"],"sourcesContent":["(ns sci.impl.interop\n  {:no-doc true}\n  #?(:clj (:import [sci.impl Reflector]))\n  (:require #?(:cljs [goog.object :as gobj])\n            [sci.impl.vars :as vars]\n            #?(:cljs [clojure.string])\n            [clojure.string :as str]))\n\n;; see https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/Reflector.java\n;; see invokeStaticMethod, getStaticField, etc.\n\n#?(:clj (set! *warn-on-reflection* true))\n\n\n#?(:cljs\n   (do\n     (defn toJS [v]\n       (if (instance? MetaFn v)\n         ;; when returning a function, make it callable from JS\n         (.-afn v)\n         (clj->js v)))\n\n     (defn js-object-array [args]\n       (to-array (map toJS args)))))\n\n(defn invoke-instance-method\n  #?@(:cljs [[obj _target-class method-name args]\n             ;; gobj/get didn't work here\n             (if (identical? \\- (.charAt method-name 0))\n               (aget obj (subs method-name 1))\n               (if-let [method (aget obj method-name)]\n                 (.apply method obj (js-object-array args))\n                 (throw (js/Error. (str \"Could not find instance method: \" method-name)))))]\n      :clj\n      [#_([obj method args]\n        (invoke-instance-method obj nil method args))\n       ([obj target-class method args]\n        (if-not target-class\n          (Reflector/invokeInstanceMethod obj method (object-array args))\n          (let [methods (Reflector/getMethods target-class (count args) method false)]\n            (Reflector/invokeMatchingMethod method methods obj (object-array args)))))]))\n\n(defn get-static-field #?(:clj [[^Class class field-name-sym]]\n                          :cljs [[class field-name-sym]])\n  #?(:clj (Reflector/getStaticField class (str field-name-sym))\n     :cljs (if (str/includes? (str field-name-sym) \".\")\n             (apply gobj/getValueByKeys class (str/split (str field-name-sym) #\"\\.\"))\n             (gobj/get class field-name-sym))))\n\n#?(:cljs\n   (defn invoke-js-constructor [constructor args]\n     (let [ctor (js/Function.prototype.bind.apply constructor)\n           args (js-object-array args)]\n       (case (count args)\n         0 (new ctor)\n         1 (new ctor (nth args 0))\n         2 (new ctor (nth args 0) (nth args 1))\n         3 (new ctor (nth args 0) (nth args 1) (nth args 2))\n         4 (new ctor (nth args 0) (nth args 1) (nth args 2) (nth args 3))\n         5 (new ctor (nth args 0) (nth args 1) (nth args 2) (nth args 3) (nth args 4))\n         6 (new ctor (nth args 0) (nth args 1) (nth args 2) (nth args 3) (nth args 4) (nth args 5))\n         7 (new ctor (nth args 0) (nth args 1) (nth args 2) (nth args 3) (nth args 4) (nth args 5) (nth args 6))\n\n         (throw (ex-info \"Constructors with more than 7 arguments are not supported\" {:constructor constructor}))))))\n\n(defn invoke-constructor #?(:clj [^Class class args]\n                            :cljs [constructor args])\n  #?(:clj (Reflector/invokeConstructor class (object-array args))\n     :cljs (invoke-js-constructor constructor args)))\n\n(defn invoke-static-method #?(:clj [[^Class class method-name] args]\n                              :cljs [[class method-name] args])\n  #?(:clj\n     (Reflector/invokeStaticMethod class (str method-name) (object-array args))\n     :cljs (if-let [method (gobj/get class method-name)]\n             (.apply method class (js-object-array args))\n             (let [method-name (str method-name)\n                   field (get-static-field [class method-name])]\n               (cond\n                 (not field)\n                 (throw (js/Error. (str \"Could not find static method \" method-name)))\n                 (clojure.string/ends-with? method-name \".\")\n                 (invoke-js-constructor field args)\n                 :else\n                 (apply (get-static-field [class method-name]) args))))))\n\n(defn fully-qualify-class [{:keys [:env :class->opts]} sym]\n  (or #?(:clj (when (contains? class->opts sym) sym)\n         :cljs (if-let [ns* (namespace sym)]\n                 (when (identical? \"js\" ns*)\n                   (when (contains? class->opts (symbol (name sym)))\n                     sym))\n                 (when (contains? class->opts sym)\n                   sym)))\n      (let [env @env]\n        (or (get (:imports env) sym)\n            (let [cnn (vars/current-ns-name)]\n              (get-in env [:namespaces cnn :imports sym]))))))\n\n(defn resolve-class-opts [{:keys [:env :class->opts]} sym]\n  (let [class-opts (or #?(:clj (get class->opts sym)\n                     :cljs (if-let [ns* (namespace sym)]\n                             (when (identical? \"js\" ns*)\n                               (get class->opts (symbol (name sym))))\n                             (get class->opts sym)))\n                       (let [env @env]\n                         (or\n                          (let [cnn (vars/current-ns-name)\n                                imports (get-in env [:namespaces cnn :imports])]\n                            (if-let [[_ v] (find imports sym)]\n                              ;; finding a nil v means the object was unmapped\n                              (get class->opts v)\n                              (when-let [v (get-in env [:imports sym])]\n                                (get class->opts v)))))))]\n    class-opts))\n\n(defn resolve-class [ctx sym]\n  (:class (resolve-class-opts ctx sym)))\n"]}