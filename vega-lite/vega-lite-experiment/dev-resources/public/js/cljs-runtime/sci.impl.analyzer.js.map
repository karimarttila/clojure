{"version":3,"sources":["sci/impl/analyzer.cljc"],"mappings":"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","names":["sci.impl.analyzer/special-syms","sci.impl.analyzer/throw-error-with-location","msg","node","sci.impl.utils.throw_error_with_location","sci.impl.analyzer/macroexpand-1","ctx","expr","original-expr","cljs.core/seq?","op","cljs.core/first","cljs.core/Symbol","cljs.core.get","cljs.core/contains?","G__52225","G__52226","sci.impl.analyzer/analyze","cljs.core.assoc","f","sci.impl.resolve.resolve_symbol","cljs.core/deref","sci.impl.vars/var?","sci.impl.vars/isMacro","sci.impl.utils/macro?","sci.impl.utils/needs-ctx","G__52229","cljs.core/meta","cljs.core.partial","cljs.core.apply","cljs.core/rest","sci.impl.analyzer/macroexpand","form","ex","cljs.core/vreset!","sci.impl.utils/macroexpand*","sci.impl.utils/macroexpand-1*","sci.impl.analyzer/analyze-children","children","p1__52230#","cljs.core.mapv","sci.impl.analyzer/maybe-destructured","params","body","cljs.core/every?","cljs.core/symbol?","new-params","cljs.core/with-meta","lets","cljs.core.sequence","cljs.core/seq","cljs.core.concat","cljs.core/List","cljs.core/next","cljs.core.conj","gparam","cljs.core.gensym","p__52270","p__52271","map__52276","cljs.core/PROTOCOL_SENTINEL","cljs.core/hash-map","fn-expr","vec__52277","seq__52278","first__52279","sci.impl.analyzer/expand-fn-args+body","fn-name","binding-vector","body-exprs","macro?","cljs.core/vector?","map__52295","cljs.core.into","fixed-args","p1__52234#","cljs.core.take_while","cljs.core.not_EQ_","fixed-arity","cljs.core/count","var-arg-name","cljs.core/second","p1__52235#","cljs.core.drop_while","next-body","conds","e","cljs.core/map?","or__4126__auto__","pre","post","cljs.core/vec","cljs.core.map","c","cljs.core.update","cljs.core/merge","cljs.core/zipmap","cljs.core.repeat","sci.impl.analyzer/analyzed-fn-meta","m","meta-needs-eval?","sci.impl.utils/mark-eval","p__52345","vec__52347","seq__52348","first__52349","sci.impl.analyzer/expand-fn","_fn","name?","cljs.core/cons","bodies","cljs.core/assoc-in","analyzed-bodies","cljs.core.reduce","p__52352","map__52353","max-fixed","min-varargs","acc","arglist","new-min-varargs","and__4115__auto__","cljs.core/not","x__4214__auto__","y__4215__auto__","cljs.core/conj","arities","arglists","fn-meta","ana-fn-meta","cljs.core.dissoc","sci.impl.analyzer/expand-let*","destructured-let-bindings","exprs","vec__52359","cljs.core.nth","new-let-bindings","p__52362","p__52363","vec__52364","vec__52367","binding-name","binding-value","v","cljs.core/assoc","cljs.core.partition","sci.impl.evaluator/eval-let","sci.impl.utils/evaluate","p__52372","vec__52375","seq__52376","first__52377","sci.impl.analyzer/expand-let","_let","let-bindings","sci.impl.destructure/destructure","sci.impl.analyzer/expand-def","vec__52380","_def","var-name","?docstring","?init","G__52383","G__52384","sci.impl.analyzer/expand-declare","cljs.core/simple-symbol?","arg-count","docstring","cljs.core._EQ_","expected-arg-count","js/Error","init","sci.impl.vars/current-ns","sci.impl.utils.mark_eval_call","p__52385","vec__52386","seq__52387","first__52388","sci.impl.analyzer/expand-defn","G__52390","G__52391","vec__52392","cljs.core/name","pre-body","cljs.core/split-with","cljs.core.comp","cljs.core/sequential?","_","cljs.core/empty?","temp__5735__auto__","ds","meta-map","cljs.core/last","G__52410","G__52411","cljs.core.merge","fn-body","G__52419","sci.impl.analyzer/expand-loop","vec__52439","bv","arg-names","cljs.core.take_nth","init-vals","syms","cljs.core.repeatedly","bv1","cljs.core/vector","bv2","cljs.core/cat","cljs.core.interleave","cljs.core/nnext","expansion","cljs.core.list_STAR_","sci.impl.analyzer/expand-lazy-seq","G__52468","G__52469","p__52474","vec__52476","seq__52477","first__52478","sci.impl.analyzer/expand-if","_if","G__52479","vec__52480","cond","then","else","sci.impl.evaluator/eval-if","sci.impl.analyzer/expand-case","G__52487","G__52488","clauses","match-clauses","result-clauses","default","cljs.core/odd?","G__52489","G__52490","cases","assoc-new","k","case-map","ret-map","vec__52494","seq__52495","first__52496","cljs.core/list?","ret","p__52497","vec__52498","seq__52499","first__52500","sci.impl.analyzer/expand-try","_try","vec__52502","catches","finally","catch-exprs","finally-expr","G__52509","G__52510","vec__52512","seq__52513","first__52514","binding","temp__5733__auto__","clazz","sci.impl.interop/resolve-class","G__52516","G__52517","G__52518","G__52519","p__52521","vec__52522","seq__52523","first__52524","_declare","names","cljs.core.swap_BANG_","env","cnn","sci.impl.vars/current-ns-name","cljs.core.update_in","current-ns","name","x","prev-ns","G__52525","current-ns-name","sci.impl.vars/getName","G__52526","sci.impl.vars/->SciVar","cljs.core.symbol","sci.impl.vars/current-file","p__52529","vec__52531","seq__52532","first__52533","sci.impl.analyzer/expand-dot","_dot","instance-expr","method-expr","args","_expr","vec__52534","seq__52535","first__52536","sci.impl.utils/vary-meta*","t","sci.impl.records/resolve-record-class","res","sci.impl.analyzer/expand-dot**","p__52539","vec__52540","seq__52541","first__52542","sci.impl.analyzer/expand-dot*","method-name","obj","cljs.core.subs","p__52544","vec__52545","seq__52546","first__52547","sci.impl.analyzer/expand-new","_new","class-sym","map__52548","constructor","_opts","sci.impl.interop/resolve-class-opts","record","p__52553","vec__52556","seq__52557","first__52558","sci.impl.analyzer/expand-constructor","constructor-sym","constructor-name","p__52561","vec__52562","seq__52563","first__52564","sci.impl.analyzer/analyze-ns-form","_ns","ns-name","cljs.core.pr_str","vec__52599","vec__52602","fexpr","attr-map","sci.impl.utils/set-namespace!","vec__52617","seq__52618","first__52619","G__52620","cljs.core/Keyword","p__52628","vec__52630","sci.impl.analyzer/analyze-var","p__52634","vec__52637","sci.impl.analyzer/analyze-set!","sci.impl.types/getVal","sci.impl.analyzer/analyze-call","top-level?","special-sym","sci.impl.resolve/check-permission!","f-meta","eval?","sci.impl.utils/ana-macros","G__52644","sci.impl.for-macro/expand-for","G__52646","G__52647","sci.impl.doseq-macro/expand-doseq","e52648","needs-ctx?","expanded","sci.impl.types/->EvalForm","sci.impl.utils/rethrow-with-location-of-node","sci.impl.analyzer/constant-colls","var_args","G__52654","sci.impl.analyzer.analyze","sci.impl.utils/constant?","sci.impl.types/->EvalVar","sci.impl.utils/merge-meta","cljs.core/record?","ks","cljs.core/keys","vs","cljs.core/vals","constant-map?","analyzed-map","analyzed-meta","cljs.core/set?","constant-coll?","analyzed-coll","cljs.core/empty"],"sourcesContent":["(ns sci.impl.analyzer\n  {:no-doc true}\n  (:refer-clojure :exclude [destructure macroexpand macroexpand-all macroexpand-1])\n  (:require\n   #?(:clj [clojure.string :as str])\n   [sci.impl.destructure :refer [destructure]]\n   [sci.impl.doseq-macro :refer [expand-doseq]]\n   [sci.impl.evaluator :as eval]\n   [sci.impl.for-macro :refer [expand-for]]\n   [sci.impl.interop :as interop]\n   [sci.impl.records :as records]\n   [sci.impl.resolve :as resolve]\n   [sci.impl.types :as types]\n   [sci.impl.utils :as utils :refer\n    [mark-eval mark-eval-call constant?\n     rethrow-with-location-of-node\n     merge-meta set-namespace!\n     macro? ana-macros]]\n   [sci.impl.vars :as vars])\n  #?(:clj (:import [sci.impl Reflector])))\n\n#?(:clj (set! *warn-on-reflection* true))\n\n;; derived from (keys (. clojure.lang.Compiler specials))\n;; (& monitor-exit case* try reify* finally loop* do letfn* if clojure.core/import* new deftype* let* fn* recur set! . var quote catch throw monitor-enter def)\n(def special-syms '#{try finally do if new recur quote catch throw def . var set!})\n\n(defn- throw-error-with-location [msg node]\n  (utils/throw-error-with-location msg node {:phase \"analysis\"}))\n\n(declare analyze analyze-call)\n\n;;;; Macros\n\n(defn macroexpand-1 [ctx expr]\n  (let [original-expr expr]\n    (if (seq? expr)\n      (let [op (first expr)]\n        (if (symbol? op)\n          (cond (get special-syms op) expr\n                (contains? #{'for} op) (analyze (assoc ctx :sci.impl/macroexpanding true)\n                                                    expr)\n                :else\n                (let [f (resolve/resolve-symbol ctx op true)\n                      f (if (and (vars/var? f)\n                                 (vars/isMacro f))\n                          @f f)]\n                  (if (macro? f)\n                    (let [f (if (identical? utils/needs-ctx (some-> f meta :sci.impl/op))\n                              (partial f ctx)\n                              f)]\n                      (apply f original-expr (:bindings ctx) (rest expr)))\n                    expr)))\n          expr))\n      expr)))\n\n(defn macroexpand\n  [ctx form]\n  (let [ex (macroexpand-1 ctx form)]\n    (if (identical? ex form)\n      form\n      (macroexpand ctx ex))))\n\n(vreset! utils/macroexpand* macroexpand)\n(vreset! utils/macroexpand-1* macroexpand-1)\n\n;;;; End macros\n\n(defn analyze-children [ctx children]\n  (mapv #(analyze ctx %) children))\n\n(defn maybe-destructured\n  [params body]\n  (if (every? symbol? params)\n    {:params params\n     :body body}\n    (loop [params params\n           new-params (with-meta [] (meta params))\n           lets []]\n      (if params\n        (if (symbol? (first params))\n          (recur (next params) (conj new-params (first params)) lets)\n          (let [gparam (gensym \"p__\")]\n            (recur (next params) (conj new-params gparam)\n                   (-> lets (conj (first params)) (conj gparam)))))\n        {:params new-params\n         :body [`(let ~lets\n                   ~@body)]}))))\n\n(defn expand-fn-args+body [{:keys [:fn-expr] :as ctx} fn-name [binding-vector & body-exprs] macro?]\n  (when-not binding-vector\n    (throw-error-with-location \"Parameter declaration missing.\" fn-expr))\n  (when-not (vector? binding-vector)\n    (throw-error-with-location \"Parameter declaration should be a vector\" fn-expr))\n  (let [binding-vector (if macro? (into ['&form '&env] binding-vector)\n                           binding-vector)\n        fixed-args (take-while #(not= '& %) binding-vector)\n        fixed-arity (count fixed-args)\n        var-arg-name (second (drop-while #(not= '& %) binding-vector))\n        next-body (next body-exprs)\n        conds (when next-body\n                (let [e (first body-exprs)]\n                  (when (map? e) e)))\n        body-exprs (if conds next-body body-exprs)\n        conds (or conds (meta binding-vector))\n        pre (:pre conds)\n        post (:post conds)\n        body-exprs (if post\n                     `((let [~'% ~(if (< 1 (count body-exprs))\n                                    `(do ~@body-exprs)\n                                    (first body-exprs))]\n                         ~@(map (fn* [c] `(assert ~c)) post)\n                         ~'%))\n                     body-exprs)\n        body-exprs (if pre\n                     (concat (map (fn* [c] `(assert ~c)) pre)\n                             body-exprs)\n                     body-exprs)\n        {:keys [:params :body]} (maybe-destructured binding-vector body-exprs)\n        ctx (update ctx :bindings merge (zipmap params\n                                                (repeat nil)))\n        body (analyze-children ctx body)]\n    #:sci.impl{:body body\n               :params params\n               :fixed-arity fixed-arity\n               :var-arg-name var-arg-name\n               :fn-name fn-name}))\n\n(defn analyzed-fn-meta [ctx m]\n  (let [;; seq expr has location info with 2 keys\n        meta-needs-eval? (> (count m) 2)\n        m (if meta-needs-eval? (mark-eval (analyze ctx m))\n              m)]\n    m))\n\n(defn expand-fn [ctx [_fn name? & body :as fn-expr] macro?]\n  (let [ctx (assoc ctx :fn-expr fn-expr)\n        fn-name (if (symbol? name?)\n                  name?\n                  nil)\n        body (if fn-name\n               body\n               (cons name? body))\n        ;; fn-name (or fn-name (gensym* \"fn\"))\n        bodies (if (seq? (first body))\n                 body\n                 [body])\n        ctx (if fn-name (assoc-in ctx [:bindings fn-name] nil)\n                ctx)\n        analyzed-bodies (reduce\n                         (fn [{:keys [:max-fixed :min-varargs] :as acc} body]\n                           (let [arglist (first body)\n                                 body (expand-fn-args+body ctx fn-name body macro?)\n                                 body (assoc body :sci.impl/arglist arglist)\n                                 var-arg-name (:sci.impl/var-arg-name body)\n                                 fixed-arity (:sci.impl/fixed-arity body)\n                                 new-min-varargs (when var-arg-name fixed-arity)]\n                             (when (and var-arg-name min-varargs)\n                               (throw-error-with-location \"Can't have more than 1 variadic overload\" fn-expr))\n                             (when (and (not var-arg-name) min-varargs (> fixed-arity min-varargs))\n                               (throw-error-with-location\n                                \"Can't have fixed arity function with more params than variadic function\" fn-expr))\n                             (-> acc\n                                 (assoc :min-varargs new-min-varargs\n                                        :max-fixed (max (:sci.impl/fixed-arity body)\n                                                        max-fixed))\n                                 (update :bodies conj body)\n                                 (update :arglists conj arglist))))\n                         {:bodies []\n                          :arglists []\n                          :min-var-args nil\n                          :max-fixed -1} bodies)\n        arities (:bodies analyzed-bodies)\n        arglists (:arglists analyzed-bodies)\n        fn-meta (meta fn-expr)\n        ana-fn-meta (analyzed-fn-meta ctx fn-meta)\n        fn-meta (when-not (identical? fn-meta ana-fn-meta)\n                  ;; fn-meta contains more than only location info\n                  (-> ana-fn-meta (dissoc :line :end-line :column :end-column)))]\n    (with-meta #:sci.impl{:fn-bodies arities\n                          :fn-name fn-name\n                          :arglists arglists\n                          :fn true\n                          :fn-meta fn-meta}\n      {:sci.impl/op :fn})))\n\n(defn expand-let*\n  [ctx destructured-let-bindings exprs]\n  (let [[ctx new-let-bindings]\n        (reduce\n         (fn [[ctx new-let-bindings] [binding-name binding-value]]\n           (let [v (analyze ctx binding-value)]\n             [(update ctx :bindings assoc binding-name v)\n              (conj new-let-bindings binding-name v)]))\n         [ctx []]\n         (partition 2 destructured-let-bindings))\n        body (analyze-children ctx exprs)]\n    (with-meta\n      (fn [ctx]\n        (eval/eval-let ctx new-let-bindings body))\n      {:sci.impl/op utils/evaluate})))\n\n(defn expand-let\n  \"The let macro from clojure.core\"\n  [ctx [_let let-bindings  & exprs]]\n  (let [let-bindings (destructure let-bindings)]\n    (expand-let* ctx let-bindings exprs)))\n\n(declare expand-declare)\n\n(defn expand-def\n  [ctx expr]\n  (let [[_def var-name ?docstring ?init] expr]\n    (expand-declare ctx [nil var-name])\n    (when-not (simple-symbol? var-name)\n      (throw-error-with-location \"Var name should be simple symbol.\" expr))\n    (let [arg-count (count expr)\n          docstring (when (and (= 4 arg-count)\n                               (string? ?docstring))\n                      ?docstring)\n          expected-arg-count (if docstring 4 3)]\n      (when-not (<= arg-count expected-arg-count)\n        (throw (new #?(:clj  IllegalArgumentException\n                       :cljs js/Error)\n                    \"Too many arguments to def\")))\n      (let [init (if docstring ?init ?docstring)\n            init (if (= 2 arg-count)\n                   :sci.impl/var.unbound\n                   (analyze ctx init))\n            m (meta var-name)\n            m (analyze ctx m)\n            m (assoc m :ns @vars/current-ns)\n            m (if docstring (assoc m :doc docstring) m)\n            var-name (with-meta var-name m)]\n        (mark-eval-call (list 'def var-name init))))))\n\n(defn expand-defn [ctx [op fn-name & body :as expr]]\n  (when-not (simple-symbol? fn-name)\n    (throw-error-with-location \"Var name should be simple symbol.\" expr))\n  (expand-declare ctx [nil fn-name])\n  (let [macro? (= \"defmacro\" (name op))\n        [pre-body body] (split-with (comp not sequential?) body)\n        _ (when (empty? body)\n            (throw-error-with-location \"Parameter declaration missing.\" expr))\n        docstring (when-let [ds (first pre-body)]\n                    (when (string? ds) ds))\n        meta-map (when-let [m (last pre-body)]\n                   (when (map? m) m))\n        meta-map (analyze ctx (merge (meta fn-name) (meta expr) meta-map))\n        fn-body (with-meta (cons 'fn body)\n                  (meta expr))\n        f (expand-fn ctx fn-body macro?)\n        arglists (seq (:sci.impl/arglists f))\n        meta-map (assoc meta-map\n                        :ns @vars/current-ns\n                        :arglists arglists)\n        fn-name (with-meta fn-name\n                  (cond-> meta-map\n                    docstring (assoc :doc docstring)\n                    macro? (assoc :macro true)))\n        f (assoc f\n                 :sci/macro macro?\n                 :sci.impl/fn-name fn-name\n                 :sci.impl/var true)]\n    (mark-eval-call (list 'def fn-name f))))\n\n(defn expand-loop\n  [ctx expr]\n  (let [bv (second expr)\n        arg-names (take-nth 2 bv)\n        init-vals (take-nth 2 (rest bv))\n        [bv syms] (if (every? symbol? arg-names)\n                    [bv arg-names]\n                    (let [syms (repeatedly (count arg-names) #(gensym))\n                          bv1 (map vector syms init-vals)\n                          bv2  (map vector arg-names syms)]\n                      [(into [] cat (interleave bv1 bv2)) syms]))\n        body (nnext expr)\n        expansion (list 'let bv\n                        (list* `(fn ~(vec arg-names) ~@body)\n                               syms))]\n    (analyze ctx expansion)))\n\n(defn expand-lazy-seq\n  [ctx expr]\n  (let [body (rest expr)]\n    (mark-eval-call\n     (list `lazy-seq\n           (analyze ctx\n                    ;; expand-fn will take care of the analysis of the body\n                    (list 'fn [] (cons 'do body)))))))\n\n(defn expand-if\n  [ctx [_if & exprs :as expr]]\n  (case (count exprs)\n    (0 1) (throw-error-with-location \"Too few arguments to if\" expr)\n    (2 3) (let [[cond then else] (analyze-children ctx exprs)]\n            (with-meta\n              (fn [ctx]\n                (eval/eval-if ctx cond then else))\n              {:sci.impl/op utils/evaluate}))\n    (throw-error-with-location \"Too many arguments to if\" expr)))\n\n(defn expand-case\n  [ctx expr]\n  (let [v (analyze ctx (second expr))\n        clauses (nnext expr)\n        match-clauses (take-nth 2 clauses)\n        result-clauses (analyze-children ctx (take-nth 2 (rest clauses)))\n        default (when (odd? (count clauses))\n                  [:val (analyze ctx (last clauses))])\n        cases (interleave match-clauses result-clauses)\n        assoc-new (fn [m k v]\n                    (if-not (contains? m k)\n                      (assoc m k v)\n                      (throw-error-with-location (str \"Duplicate case test constant \" k)\n                                                 expr)))\n        case-map (loop [cases (seq cases)\n                        ret-map {}]\n                   (if cases\n                     (let [[k v & cases] cases]\n                       (if (list? k)\n                         (recur\n                          cases\n                          (reduce (fn [acc k]\n                                    (assoc-new acc k v))\n                                  ret-map\n                                  k))\n                         (recur\n                          cases\n                          (assoc-new ret-map k v))))\n                     ret-map))\n        ret (mark-eval-call (list 'case\n                                  {:case-map case-map\n                                   :case-val v\n                                   :case-default default}\n                                  default))]\n    (mark-eval-call ret)))\n\n(defn expand-try\n  [ctx [_try & body]]\n  (let [[body-exprs\n         catches\n         finally]\n        (loop [exprs #_[expr & exprs :as all-exprs] (seq body)\n               body-exprs []\n               catch-exprs []\n               finally-expr nil]\n          (if exprs\n            (let [expr (first exprs)\n                  exprs (next exprs)]\n              (cond (and (seq? expr) (= 'catch (first expr)))\n                    (recur exprs body-exprs (conj catch-exprs expr) finally-expr)\n                    (and (not exprs) (and (seq? expr) (= 'finally (first expr))))\n                    [body-exprs catch-exprs expr]\n                    :else\n                    ;; TODO: cannot add body expression when catch is not empty\n                    ;; TODO: can't have finally as non-last expression\n                    (recur exprs (conj body-exprs expr) catch-exprs finally-expr)))\n            [body-exprs catch-exprs finally-expr]))\n        body (analyze ctx (cons 'do body-exprs))\n        catches (mapv (fn [c]\n                        (let [[_ ex binding & body] c]\n                          (if-let [clazz (interop/resolve-class ctx ex)]\n                            {:class clazz\n                             :binding binding\n                             :body (analyze (assoc-in ctx [:bindings binding] nil)\n                                            (cons 'do body))}\n                            (throw-error-with-location (str \"Unable to resolve classname: \" ex) ex))))\n                      catches)\n        finally (when finally\n                  (analyze ctx (cons 'do (rest finally))))]\n    (with-meta\n      {:sci.impl/try\n       {:body body\n        :catches catches\n        :finally finally}}\n      {:sci.impl/op :try})))\n\n(defn expand-declare [ctx [_declare & names :as expr]]\n  (swap! (:env ctx)\n         (fn [env]\n           (let [cnn (vars/current-ns-name)]\n             (update-in env [:namespaces cnn]\n                        (fn [current-ns]\n                          (reduce (fn [acc name]\n                                    (if-let [x (.get ^java.util.Map acc name)]\n                                      (if-let [prev-ns (some-> x meta :ns)]\n                                        (let [current-ns-name (vars/current-ns-name)]\n                                          (if-not (= (vars/getName prev-ns)\n                                                     current-ns-name)\n                                            (throw-error-with-location\n                                             (str name \" already refers to \"\n                                                  x \" in namespace \"\n                                                  current-ns-name)\n                                             expr)\n                                            ;; when the previous bound thing\n                                            ;; didn't have an ns, just assume\n                                            ;; things are ok to redefine\n                                            acc))\n                                        ;; declare does not override an existing var\n                                        acc)\n                                      (assoc acc name\n                                             (doto (vars/->SciVar nil (symbol (str cnn)\n                                                                              (str name))\n                                                                  (assoc (meta name)\n                                                                         :name name\n                                                                         :ns @vars/current-ns\n                                                                         :file @vars/current-file)\n                                                                  false)\n                                               (vars/unbind)))))\n                                  current-ns\n                                  names))))))\n  nil)\n\n;;;; Interop\n\n(defn expand-dot [ctx [_dot instance-expr method-expr & args :as _expr]]\n  (let [[method-expr & args] (if (seq? method-expr) method-expr\n                                 (cons method-expr args))\n        instance-expr (analyze ctx instance-expr)\n        instance-expr (utils/vary-meta*\n                       instance-expr\n                       (fn [m]\n                         (if-let [t (:tag m)]\n                           (let [clazz (or (interop/resolve-class ctx t)\n                                           (records/resolve-record-class ctx t)\n                                           (throw-error-with-location\n                                            (str \"Unable to resolve classname: \" t) t))]\n                             (assoc m :tag-class clazz))\n                           m)))\n        method-expr (name method-expr)\n        args (when args (analyze-children ctx args))\n        res #?(:clj (if (class? instance-expr)\n                      (if (nil? args)\n                        (if (str/starts-with? method-expr \"-\")\n                          (with-meta [instance-expr (subs method-expr 1)]\n                            {:sci.impl/op :static-access})\n                          ;; https://clojure.org/reference/java_interop\n                          ;; If the second operand is a symbol and no args are\n                          ;; supplied it is taken to be a field access - the\n                          ;; name of the field is the name of the symbol, and\n                          ;; the value of the expression is the value of the\n                          ;; field, unless there is a no argument public method\n                          ;; of the same name, in which case it resolves to a\n                          ;; call to the method.\n                          (if-let [_\n                                   (try (Reflector/getStaticField ^Class instance-expr ^String method-expr)\n                                        (catch IllegalArgumentException _ nil))]\n                            (with-meta [instance-expr method-expr]\n                              {:sci.impl/op :static-access})\n                            (mark-eval-call\n                             `(~(with-meta [instance-expr method-expr]\n                                  {:sci.impl/op :static-access}) ~@args))))\n                        (mark-eval-call\n                         `(~(with-meta [instance-expr method-expr]\n                              {:sci.impl/op :static-access}) ~@args)))\n                      (mark-eval-call `(~'. ~instance-expr ~method-expr ~args)))\n               :cljs (mark-eval-call `(~'. ~instance-expr ~method-expr ~args)))]\n    res))\n\n(defn expand-dot**\n  \"Expands (. x method)\"\n  [ctx expr]\n  (when (< (count expr) 3)\n    (throw (new #?(:clj IllegalArgumentException :cljs js/Error)\n                \"Malformed member expression, expecting (.member target ...)\")))\n  (expand-dot ctx expr))\n\n(defn expand-dot*\n  \"Expands (.foo x)\"\n  [ctx [method-name obj & args :as expr]]\n  (when (< (count expr) 2)\n    (throw (new #?(:clj IllegalArgumentException :cljs js/Error)\n                \"Malformed member expression, expecting (.member target ...)\")))\n  (expand-dot ctx (list '. obj (cons (symbol (subs (name method-name) 1)) args))))\n\n(defn expand-new [ctx [_new class-sym & args :as _expr]]\n  (if-let [#?(:clj {:keys [:class] :as _opts}\n              :cljs {:keys [:constructor] :as _opts}) (interop/resolve-class-opts ctx class-sym)]\n    (let [args (analyze-children ctx args)] ;; analyze args!\n      (mark-eval-call (list 'new #?(:clj class :cljs constructor) args)))\n    (if-let [record (records/resolve-record-class ctx class-sym)]\n      (let [args (analyze-children ctx args)]\n        (mark-eval-call (list* (:sci.impl.record/constructor (meta record)) args)))\n      (throw-error-with-location (str \"Unable to resolve classname: \" class-sym) class-sym))))\n\n(defn expand-constructor [ctx [constructor-sym & args]]\n  (let [constructor-name (name constructor-sym)\n        class-sym (with-meta (symbol (subs constructor-name 0\n                                           (dec (count constructor-name))))\n                    (meta constructor-sym))]\n    (expand-new ctx (with-meta (list* 'new class-sym args)\n                      (meta constructor-sym)))))\n\n;;;; End interop\n\n;;;; Namespaces\n\n(defn analyze-ns-form [ctx [_ns ns-name & exprs]]\n  (when-not (symbol? ns-name)\n    (throw (new #?(:clj IllegalArgumentException\n                   :cljs js/Error)\n                (str \"Namespace name must be symbol, got: \" (pr-str ns-name)))))\n  (let [[docstring exprs]\n        (let [fexpr (first exprs)]\n          (if (string? fexpr)\n            [fexpr (next exprs)]\n            [nil exprs]))\n        ;; skip attr-map\n        [attr-map exprs]\n        (let [m (first exprs)]\n          (if (map? m)\n            [m (next exprs)]\n            [nil exprs]))\n        attr-map (if docstring\n                   (assoc attr-map :doc docstring)\n                   attr-map)]\n    (set-namespace! ctx ns-name attr-map)\n    (loop [exprs exprs\n           ret []]\n      (if exprs\n        (let [[k & args :as expr] (first exprs)]\n          (case k\n            (:require :use)\n            (recur (next exprs)\n                   (conj ret\n                         (mark-eval-call\n                          (with-meta (list* (symbol (name k)) args)\n                            (meta expr)))))\n            :import (recur (next exprs) (conj ret (mark-eval-call\n                                                   (with-meta (list* 'import args)\n                                                     (meta expr)))))\n            :refer-clojure (recur (next exprs)\n                                  (conj ret\n                                        (mark-eval-call\n                                         (with-meta (list* 'refer 'clojure.core args)\n                                           (meta expr)))))\n            :gen-class ;; ignore\n            (recur (next exprs) ret)))\n        (mark-eval-call (list* 'do ret))))))\n\n;;;; End namespaces\n\n\n;;;; Vars\n\n(defn analyze-var [ctx [_ var-name]]\n  (resolve/resolve-symbol (assoc ctx :sci.impl/prevent-deref true) var-name))\n\n(defn analyze-set! [ctx [_ obj v]]\n  (let [obj (analyze ctx obj)\n        v (analyze ctx v)\n        obj (types/getVal obj)]\n    (mark-eval-call (list 'set! obj v))))\n\n;;;; End vars\n\n(defn analyze-call [ctx expr top-level?]\n  (let [f (first expr)]\n    (if (symbol? f)\n      (let [;; in call position Clojure prioritizes special symbols over\n            ;; bindings\n            special-sym (get special-syms f)\n            _ (when special-sym (resolve/check-permission! ctx special-sym f nil))\n            f (or special-sym\n                  (resolve/resolve-symbol ctx f true))\n            #_#_f (if (and (vars/var? f)\n                           (vars/isMacro f))\n                    f f)\n            f-meta (meta f)\n            eval? (and f-meta (:sci.impl/op f-meta))]\n        (cond (and f-meta (::static-access f-meta))\n              (expand-dot** ctx (list* '. (first f) (second f) (rest expr)))\n              (and (not eval?) ;; the symbol is not a binding\n                   (or\n                    special-sym\n                    (contains? ana-macros f)))\n              (case f\n                ;; we treat every subexpression of a top-level do as a separate\n                ;; analysis/interpretation unit so we hand this over to the\n                ;; interpreter again, which will invoke analysis + evaluation on\n                ;; every sub expression\n                do (mark-eval-call (cons 'do\n                                         (analyze-children ctx (rest expr))))\n                let (expand-let ctx expr)\n                (fn fn*) (expand-fn ctx expr false)\n                def (expand-def ctx expr)\n                ;; NOTE: defn / defmacro aren't implemented as normal macros yet\n                (defn defmacro) (let [ret (expand-defn ctx expr)]\n                                  ret)\n                ;; TODO: implement as normal macro in namespaces.cljc\n                loop (expand-loop ctx expr)\n                lazy-seq (expand-lazy-seq ctx expr)\n                for (let [res (expand-for ctx expr)]\n                      (if (:sci.impl/macroexpanding ctx)\n                        res\n                        (analyze ctx res)))\n                doseq (analyze ctx (expand-doseq ctx expr))\n                if (expand-if ctx expr)\n                case (expand-case ctx expr)\n                try (expand-try ctx expr)\n                declare (expand-declare ctx expr)\n                expand-dot* (expand-dot* ctx expr)\n                . (expand-dot** ctx expr)\n                expand-constructor (expand-constructor ctx expr)\n                new (expand-new ctx expr)\n                ns (analyze-ns-form ctx expr)\n                var (analyze-var ctx expr)\n                set! (analyze-set! ctx expr)\n                (import quote) (mark-eval-call expr) ;; don't analyze children\n                ;; else:\n                (mark-eval-call (cons f (analyze-children ctx (rest expr)))))\n              :else\n              (try\n                (if (macro? f)\n                  (let [needs-ctx? (identical? utils/needs-ctx\n                                               (:sci.impl/op (meta f)))\n                        v (if needs-ctx?\n                            (apply f expr\n                                   (:bindings ctx)\n                                   ctx\n                                   (rest expr))\n                            (apply f expr\n                                   (:bindings ctx) (rest expr)))\n                        expanded (cond (:sci.impl/macroexpanding ctx) v\n                                       (and top-level? (seq? v) (= 'do (first v)))\n                                       ;; hand back control to eval-form for\n                                       ;; interleaved analysis and eval\n                                       (types/->EvalForm v)\n                                       :else (analyze ctx v))]\n                    expanded)\n                  (if-let [f (:sci.impl/inlined f-meta)]\n                    (mark-eval-call (cons f (analyze-children ctx (rest expr)))\n                                    :sci.impl/f-meta f-meta)\n                    (mark-eval-call (cons f (analyze-children ctx (rest expr))))))\n                (catch #?(:clj Exception :cljs js/Error) e\n                  (rethrow-with-location-of-node ctx e\n                                                 ;; adding metadata for error reporting\n                                                 (mark-eval-call\n                                                  (with-meta (cons f (rest expr))\n                                                    (meta expr))))))))\n      (let [ret (mark-eval-call (analyze-children ctx expr))]\n        ret))))\n\n(def ^:const constant-colls true) ;; see GH #452\n\n(defn analyze\n  ([ctx expr]\n   (analyze ctx expr false))\n  ([ctx expr top-level?]\n   ;; (prn :ana expr)\n   (let [m (meta expr)\n         ret (cond (constant? expr) expr ;; constants do not carry metadata\n                   (symbol? expr) (let [v (resolve/resolve-symbol ctx expr false)]\n                                    (cond (constant? v) v\n                                          (vars/var? v)\n                                          (if (:const (meta v))\n                                            @v\n                                            (if (vars/isMacro v)\n                                              (throw (new #?(:clj IllegalStateException :cljs js/Error)\n                                                          (str \"Can't take value of a macro: \" v \"\")))\n                                              (types/->EvalVar v)))\n                                          :else (merge-meta v m)))\n                   ;; don't evaluate records, this check needs to go before map?\n                   ;; since a record is also a map\n                   (record? expr) expr\n                   (map? expr)\n                   (let [ks (keys expr)\n                         vs (vals expr)\n                         constant-map? (and constant-colls\n                                            (every? constant? ks)\n                                            (every? constant? vs))\n                         analyzed-map (if constant-map?\n                                        expr\n                                        ;; potential place for optimization\n                                        (zipmap (analyze-children ctx ks)\n                                                (analyze-children ctx vs)))\n                         analyzed-meta (when m (analyze ctx m))\n                         analyzed-meta (if (and constant-map?\n                                                ;; meta was also a constant-map\n                                                (identical? m analyzed-meta))\n                                         analyzed-meta\n                                         (assoc analyzed-meta :sci.impl/op :eval))]\n                     (if analyzed-meta\n                       (with-meta analyzed-map analyzed-meta)\n                       analyzed-map))\n                   (or (vector? expr) (set? expr))\n                   (let [constant-coll? (and constant-colls\n                                             (every? constant? expr))\n                         analyzed-coll (if constant-coll?\n                                         expr\n                                         (into (empty expr) (analyze-children ctx expr)))\n                         analyzed-meta (when m (analyze ctx m))\n                         analyzed-meta (if (and constant-coll?\n                                                (identical? m analyzed-meta))\n                                         analyzed-meta\n                                         (assoc analyzed-meta :sci.impl/op :eval))]\n                     (if analyzed-meta\n                       (with-meta analyzed-coll analyzed-meta)\n                       analyzed-coll))\n                   (seq? expr) (if (seq expr)\n                                 (merge-meta (analyze-call ctx expr top-level?) m)\n                                 ;; the empty list\n                                 expr)\n                   :else\n                   expr)]\n     ret)))\n\n;;;; Scratch\n\n(comment\n  )\n"]}