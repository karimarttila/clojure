{"version":3,"sources":["sci/impl/resolve.cljc"],"mappings":"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","names":["sci.impl.resolve/throw-error-with-location","msg","node","sci.impl.utils.throw_error_with_location","sci.impl.resolve/mark-resolve-sym","sym","cljs.core.vary_meta","m","cljs.core.assoc","p__49574","map__49575","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply","cljs.core/hash-map","allow","cljs.core.get","deny","sci.impl.resolve/check-permission!","check-sym","v","or__4126__auto__","sci.impl.utils/allowed-loop","sci.impl.utils/allowed-recur","sci.impl.utils/strip-core-ns","sci.impl.vars/var?","cljs.core/not","cljs.core/meta","cljs.core/contains?","p__49668","map__49669","env","sci.impl.resolve/lookup*","ctx","call?","cljs.core/deref","sym-ns","G__49671","cljs.core/namespace","cljs.core.symbol","sym-name","cljs.core/name","cnn","sci.impl.vars/current-ns-name","the-current-ns","G__49673","cljs.core.get_in","cljs.core/find","and__4115__auto__","cljs.core._EQ_","G__49706","temp__5735__auto__","sci.impl.utils/ana-macros","G__49709","clazz","sci.impl.interop/resolve-class","cljs.core/with-meta","kv","G__49807","G__49808","c","x","sci.impl.records.resolve_record_or_protocol_class","sci.impl.resolve/tag","_ctx","expr","p__49810","map__49811","bindings","sci.impl.resolve/lookup","vec__49813","cljs.core.nth","k","vec__49819","t","cljs.core/assoc","vec__49822","temp__5733__auto__","cljs.core/vreset!","sci.impl.utils/lookup","var_args","G__49861","sci.impl.resolve/resolve-symbol","js/Error","sci.impl.resolve.resolve_symbol","res","cljs.core/second","n","clojure.string/starts-with?","clojure.string/ends-with?","cljs.core.subs"],"sourcesContent":["(ns sci.impl.resolve\n  {:no-doc true}\n  (:require [clojure.string :as str]\n            ;; [sci.impl.evaluator :as eval]\n            ;; [sci.impl.faster :as faster]\n            [sci.impl.interop :as interop]\n            [sci.impl.records :as records]\n            [sci.impl.utils :as utils :refer [strip-core-ns\n                                              ana-macros]]\n            [sci.impl.vars :as vars]))\n\n(defn throw-error-with-location [msg node]\n  (utils/throw-error-with-location msg node {:phase \"analysis\"}))\n\n(defn mark-resolve-sym\n  [sym]\n  (vary-meta\n   sym\n   (fn [m]\n     (assoc m :sci.impl/op :resolve-sym))))\n\n(defn check-permission! [{:keys [:allow :deny]} check-sym sym v]\n  (or (identical? utils/allowed-loop sym)\n      (identical? utils/allowed-recur sym)\n      (let [check-sym (strip-core-ns check-sym)]\n        (when-not (if allow (or (and (vars/var? v) (not (:sci.impl/built-in (meta v))))\n                                (contains? allow check-sym))\n                      true)\n          (throw-error-with-location (str sym \" is not allowed!\") sym))\n        (when (if deny (contains? deny check-sym)\n                  false)\n          (throw-error-with-location (str sym \" is not allowed!\") sym)))))\n\n(defn lookup* [{:keys [:env] :as ctx} sym call?]\n  (let [sym-ns (some-> (namespace sym) symbol)\n        sym-name (symbol (name sym))\n        env @env\n        cnn (vars/current-ns-name)\n        the-current-ns (-> env :namespaces cnn)\n        ;; resolve alias\n        sym-ns (when sym-ns (or (get-in the-current-ns [:aliases sym-ns])\n                                sym-ns))]\n    (or (find the-current-ns sym) ;; env can contain foo/bar symbols from bindings\n        (cond\n          (and sym-ns (or (= sym-ns 'clojure.core) (= sym-ns 'cljs.core)))\n          (or (some-> env :namespaces (get 'clojure.core) (find sym-name))\n              (when-let [v (when call? (get ana-macros sym-name))]\n                [sym v]))\n          sym-ns\n          (or (some-> env :namespaces sym-ns (find sym-name))\n              (when-let [clazz (interop/resolve-class ctx sym-ns)]\n                [sym (with-meta\n                       [clazz sym-name]\n                       #?(:clj\n                          (if call?\n                            {:sci.impl.analyzer/static-access true}\n                            {:sci.impl/op :static-access\n                             :file @vars/current-file\n                             :ns @vars/current-ns})\n                          :cljs {:sci.impl/op :static-access}))]))\n          :else\n          ;; no sym-ns, this could be a symbol from clojure.core\n          (or\n           (let [kv (some-> env :namespaces (get 'clojure.core) (find sym-name))]\n             ;; only valid when the symbol isn't excluded\n             (when-not (some-> the-current-ns\n                               :refer\n                               (get 'clojure.core)\n                               :exclude\n                               (contains? sym-name))\n               kv))\n           (when (when call? (get ana-macros sym))\n             [sym sym])\n           (when-let [c (interop/resolve-class ctx sym)]\n             [sym c])\n           ;; resolves record or protocol referenced as class\n           ;; e.g. clojure.lang.IDeref which is really a var in clojure.lang/IDeref\n           (when-let [x (records/resolve-record-or-protocol-class ctx sym)]\n             [sym x]))))))\n\n(defn tag [_ctx expr]\n  (when-let [m (meta expr)]\n    (:tag m)))\n\n(defn lookup [{:keys [:bindings] :as ctx} sym call?]\n  (let [[k v :as kv]\n        (or\n         ;; bindings are not checked for permissions\n         (when-let [[k v]\n                    (find bindings sym)]\n           ;; never inline a binding at macro time!\n           (let [t (tag ctx v)\n                 v (mark-resolve-sym k)\n                 ;; pass along tag of expression!\n                 v (if t (vary-meta v\n                                    assoc :tag t)\n                       v)]\n             [k v]))\n         (when-let\n             [[k v :as kv]\n              (or\n               (lookup* ctx sym call?)\n               #_(when (= 'recur sym)\n                   [sym sym]))]\n           (check-permission! ctx k sym v)\n           kv))]\n    ;; (prn 'lookup sym '-> res)\n    (if-let [m (and (not (:sci.impl/prevent-deref ctx))\n                    (meta k))]\n      (if (:sci.impl/deref! m)\n        ;; the evaluation of this expression has been delayed by\n        ;; the caller and now is the time to deref it\n        [k (with-meta [v]\n             {:sci.impl/op :deref!})]\n        kv)\n      kv)))\n\n;; workaround for evaluator also needing this function\n(vreset! utils/lookup lookup)\n\n(defn resolve-symbol\n  ([ctx sym] (resolve-symbol ctx sym false))\n  ([ctx sym call?]\n   (let [sym sym ;; (strip-core-ns sym)\n         res (second\n              (or\n               (lookup ctx sym call?)\n               ;; TODO: check if symbol is in macros and then emit an error: cannot take\n               ;; the value of a macro\n               (let [n (name sym)]\n                 (cond\n                   (and call?\n                        (str/starts-with? n \".\")\n                        (> (count n) 1))\n                   [sym 'expand-dot*] ;; method invocation\n                   (and call?\n                        (str/ends-with? n \".\")\n                        (> (count n) 1))\n                   [sym 'expand-constructor]\n                   (str/starts-with? n \"'\") ;; TODO: deprecated?\n                   (let [v (symbol (subs n 1))]\n                     [v v])\n                   :else\n                   (throw-error-with-location\n                    (str \"Could not resolve symbol: \" (str sym))\n                    sym)))))]\n     ;; (prn 'resolve sym '-> res (meta res))\n     res)))\n"]}