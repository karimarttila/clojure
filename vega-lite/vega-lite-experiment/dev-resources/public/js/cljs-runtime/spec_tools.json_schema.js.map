{"version":3,"sources":["spec_tools/json_schema.cljc"],"mappings":"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","names":["spec-tools.json-schema/only-entry?","key","a-map","cljs.core._EQ_","cljs.core/keys","spec-tools.json-schema/simplify-all-of","spec","subspecs","cljs.core.remove","cljs.core/empty?","cljs.core.dissoc","cljs.core/count","cljs.core/first","cljs.core.assoc","spec-tools.json-schema/spec-dispatch","dispatch","_","js/spec-tools","js/spec-tools.json-schema","js/spec-tools.json-schema.accept-spec","method-table__4619__auto__","cljs.core.atom","prefer-table__4620__auto__","method-cache__4621__auto__","cached-hierarchy__4622__auto__","hierarchy__4623__auto__","cljs.core.get","fexpr__78988","cljs.core/MultiFn","cljs.core.symbol","spec-tools.json-schema/accept-spec","var_args","G__78991","spec-tools.json-schema/transform","js/Error","spec_tools.json_schema.transform","options","spec_tools.visitor.visit","children","spec-tools.json-schema/maybe-with-title","schema","temp__5733__auto__","title","and__4115__auto__","infer-titles?","spec-tools.core/spec-name","spec-tools.impl/qualified-name","map__79118","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply","cljs.core/hash-map","req","req-un","opt","opt-un","spec-tools.impl/parse-keys","spec-tools.impl/extract-form","names-un","cljs.core.map","cljs.core/name","cljs.core.concat","names","required","required-un","all-required","cljs.core/not-empty","cljs.core.merge","cljs.core/zipmap","cljs.core/vec","spec-tools.json-schema/accept-merge","cljs.core.mapcat","cljs.core.reduce","cljs.core/merge","cljs.core/into","cljs.core/sorted-set","cljs.core.into","map__79132","form","type","spec-tools.parse/parse-spec","G__79138","cljs.core/Keyword","spec-tools.impl/unwrap","cljs.core/second","vec__79143","cljs.core.nth","minimum","maximum","spec-tools.impl/strip-fn-if-needed","vec__79146","data","name","synthetic?","spec-tools.core/get-spec","json-schema-meta","spec-tools.impl/unlift-keys","extra-info","cljs.core/select-keys","G__79149","cljs.core/not","or__4126__auto__"],"sourcesContent":["(ns spec-tools.json-schema\n  \"Tools for converting specs into JSON Schemata. The version of JSON-Schema\n  generated is [draft-04](https://json-schema.org/specification-links.html#draft-4).\"\n  (:require [spec-tools.visitor :as visitor]\n            [spec-tools.parse :as parse]\n            [spec-tools.impl :as impl]\n            [spec-tools.core :as st]))\n\n(defn- only-entry? [key a-map] (= [key] (keys a-map)))\n\n(defn- simplify-all-of [spec]\n  (let [subspecs (->> (:allOf spec) (remove empty?))]\n    (cond\n      (empty? subspecs) (dissoc spec :allOf)\n      (and (= (count subspecs) 1) (only-entry? :allOf spec)) (first subspecs)\n      :else (assoc spec :allOf subspecs))))\n\n(defn- spec-dispatch [dispatch _ _ _] dispatch)\n\n(defmulti accept-spec spec-dispatch :default ::default)\n\n(defn transform\n  ([spec]\n   (transform spec nil))\n  ([spec options]\n   (visitor/visit spec accept-spec options)))\n\n;;\n;; predicate list taken from https://github.com/clojure/clojure/blob/master/src/clj/clojure/spec/gen.clj\n;;\n\n; any? (one-of [(return nil) (any-printable)])\n(defmethod accept-spec 'clojure.core/any? [_ _ _ _] {})\n\n; some? (such-that some? (any-printable))\n(defmethod accept-spec 'clojure.core/some? [_ _ _ _] {})\n\n; number? (one-of [(large-integer) (double)])\n(defmethod accept-spec 'clojure.core/number? [_ _ _ _] {:type \"number\" :format \"double\"})\n\n(defmethod accept-spec 'clojure.core/pos? [_ _ _ _] {:minimum 0 :exclusiveMinimum true})\n\n(defmethod accept-spec 'clojure.core/neg? [_ _ _ _] {:maximum 0 :exclusiveMaximum true})\n\n; integer? (large-integer)\n(defmethod accept-spec 'clojure.core/integer? [_ _ _ _] {:type \"integer\"})\n\n; int? (large-integer)\n(defmethod accept-spec 'clojure.core/int? [_ _ _ _] {:type \"integer\" :format \"int64\"})\n\n; pos-int? (large-integer* {:min 1})\n(defmethod accept-spec 'clojure.core/pos-int? [_ _ _ _] {:type \"integer\", :format \"int64\", :minimum 1})\n\n; neg-int? (large-integer* {:max -1})\n(defmethod accept-spec 'clojure.core/neg-int? [_ _ _ _] {:type \"integer\", :format \"int64\", :maximum -1})\n\n; nat-int? (large-integer* {:min 0})\n(defmethod accept-spec 'clojure.core/nat-int? [_ _ _ _] {:type \"integer\", :format \"int64\" :minimum 0})\n\n; float? (double)\n(defmethod accept-spec 'clojure.core/float? [_ _ _ _] {:type \"number\"})\n\n; double? (double)\n(defmethod accept-spec 'clojure.core/double? [_ _ _ _] {:type \"number\"})\n\n; boolean? (boolean)\n(defmethod accept-spec 'clojure.core/boolean? [_ _ _ _] {:type \"boolean\"})\n\n; string? (string-alphanumeric)\n(defmethod accept-spec 'clojure.core/string? [_ _ _ _] {:type \"string\"})\n\n; ident? (one-of [(keyword-ns) (symbol-ns)])\n(defmethod accept-spec 'clojure.core/ident? [_ _ _ _] {:type \"string\"})\n\n; simple-ident? (one-of [(keyword) (symbol)])\n(defmethod accept-spec 'clojure.core/simple-ident? [_ _ _ _] {:type \"string\"})\n\n; qualified-ident? (such-that qualified? (one-of [(keyword-ns) (symbol-ns)]))\n(defmethod accept-spec 'clojure.core/qualified-ident? [_ _ _ _] {:type \"string\"})\n\n; keyword? (keyword-ns)\n(defmethod accept-spec 'clojure.core/keyword? [_ _ _ _] {:type \"string\"})\n\n; simple-keyword? (keyword)\n(defmethod accept-spec 'clojure.core/simple-keyword? [_ _ _ _] {:type \"string\"})\n\n; qualified-keyword? (such-that qualified? (keyword-ns))\n(defmethod accept-spec 'clojure.core/qualified-keyword? [_ _ _ _] {:type \"string\"})\n\n; symbol? (symbol-ns)\n(defmethod accept-spec 'clojure.core/symbol? [_ _ _ _] {:type \"string\"})\n\n; simple-symbol? (symbol)\n(defmethod accept-spec 'clojure.core/simple-symbol? [_ _ _ _] {:type \"string\"})\n\n; qualified-symbol? (such-that qualified? (symbol-ns))\n(defmethod accept-spec 'clojure.core/qualified-symbol? [_ _ _ _] {:type \"string\"})\n\n; uuid? (uuid)\n(defmethod accept-spec 'clojure.core/uuid? [_ _ _ _] {:type \"string\" :format \"uuid\"})\n\n; uri? (fmap #(java.net.URI/create (str \"http://\" % \".com\")) (uuid))\n(defmethod accept-spec 'clojure.core/uri? [_ _ _ _] {:type \"string\" :format \"uri\"})\n\n; bigdec? (fmap #(BigDecimal/valueOf %)\n;               (double* {:infinite? false :NaN? false}))\n(defmethod accept-spec 'clojure.core/decimal? [_ _ _ _] {:type \"number\" :format \"double\"})\n\n; inst? (fmap #(java.util.Date. %)\n;             (large-integer))\n(defmethod accept-spec 'clojure.core/inst? [_ _ _ _] {:type \"string\" :format \"date-time\"})\n\n; seqable? (one-of [(return nil)\n;                   (list simple)\n;                   (vector simple)\n;                   (map simple simple)\n;                   (set simple)\n;                   (string-alphanumeric)])\n(defmethod accept-spec 'clojure.core/seqable? [_ _ _ _] {:type \"array\"})\n\n; indexed? (vector simple)\n(defmethod accept-spec 'clojure.core/map? [_ _ _ _] {:type \"array\"})\n\n; map? (map simple simple)\n(defmethod accept-spec 'clojure.core/map? [_ _ _ _] {:type \"object\"})\n\n; vector? (vector simple)\n(defmethod accept-spec 'clojure.core/vector? [_ _ _ _] {:type \"array\"})\n\n; list? (list simple)\n(defmethod accept-spec 'clojure.core/list? [_ _ _ _] {:type \"array\"})\n\n; seq? (list simple)\n(defmethod accept-spec 'clojure.core/seq? [_ _ _ _] {:type \"array\"})\n\n; char? (char)\n(defmethod accept-spec 'clojure.core/char? [_ _ _ _] {:type \"string\"})\n\n; set? (set simple)\n(defmethod accept-spec 'clojure.core/set? [_ _ _ _] {:type \"array\" :uniqueItems true})\n\n; nil? (return nil)\n(defmethod accept-spec 'clojure.core/nil? [_ _ _ _] {:type \"null\"})\n\n; false? (return false)\n(defmethod accept-spec 'clojure.core/false? [_ _ _ _] {:type \"boolean\"})\n\n; true? (return true)\n(defmethod accept-spec 'clojure.core/true? [_ _ _ _] {:type \"boolean\"})\n\n; zero? (return 0)\n(defmethod accept-spec 'clojure.core/zero? [_ _ _ _] {:type \"integer\"})\n\n; rational? (one-of [(large-integer) (ratio)])\n#?(:clj (defmethod accept-spec 'clojure.core/rational? [_ _ _ _] {:type \"double\"}))\n\n; coll? (one-of [(map simple simple)\n;                (list simple)\n;                (vector simple)\n;                (set simple)])\n(defmethod accept-spec 'clojure.core/coll? [_ _ _ _] {:type \"object\"})\n\n; empty? (elements [nil '() [] {} #{}])\n(defmethod accept-spec 'clojure.core/empty? [_ _ _ _] {:type \"array\" :maxItems 0 :minItems 0})\n\n; associative? (one-of [(map simple simple) (vector simple)])\n(defmethod accept-spec 'clojure.core/associative? [_ _ _ _] {:type \"object\"})\n\n; sequential? (one-of [(list simple) (vector simple)])\n(defmethod accept-spec 'clojure.core/sequential? [_ _ _ _] {:type \"array\"})\n\n; ratio? (such-that ratio? (ratio))\n(defmethod accept-spec 'clojure.core/ratio? [_ _ _ _] {:type \"integer\"})\n\n; bytes? (bytes)\n(defmethod accept-spec 'clojure.core/bytes? [_ _ _ _] {:type \"string\" :format \"byte\"})\n\n(defmethod accept-spec ::visitor/set [dispatch spec children _]\n  {:enum children})\n\n(defn- maybe-with-title [schema spec options]\n  (letfn [(infer-titles? [options] (-> options :infer-titles false? not))]\n    (if-let [title (and (infer-titles? options) (st/spec-name spec))]\n      (assoc schema :title (impl/qualified-name title))\n      schema)))\n\n(defmethod accept-spec 'clojure.spec.alpha/keys [_ spec children options]\n  (let [{:keys [req req-un opt opt-un]} (impl/parse-keys (impl/extract-form spec))\n        names-un (map name (concat req-un opt-un))\n        names (map impl/qualified-name (concat req opt))\n        required (map impl/qualified-name req)\n        required-un (map name req-un)\n        all-required (not-empty (concat required required-un))]\n    (maybe-with-title\n      (merge\n        {:type \"object\"\n         :properties (zipmap (concat names names-un) children)}\n        (when all-required\n          {:required (vec all-required)}))\n      spec\n      options)))\n\n(defmethod accept-spec 'clojure.spec.alpha/or [_ _ children _]\n  {:anyOf children})\n\n(defmethod accept-spec 'clojure.spec.alpha/and [_ _ children _]\n  (simplify-all-of {:allOf children}))\n\n(defn- accept-merge [children spec options]\n  (maybe-with-title\n    {:type \"object\"\n     :properties (->> (concat children\n                              (mapcat :anyOf children)\n                              (mapcat :allOf children))\n                      (map :properties)\n                      (reduce merge {}))\n     :required (->> (concat children\n                            (mapcat :allOf children))\n                    (map :required)\n                    (reduce into (sorted-set))\n                    (into []))}\n    spec\n    options))\n\n(defmethod accept-spec 'clojure.spec.alpha/merge [_ spec children options]\n  (accept-merge children spec options))\n\n(defmethod accept-spec 'spec-tools.core/merge [_ spec children options]\n  (accept-merge children spec options))\n\n(defmethod accept-spec 'clojure.spec.alpha/every [_ spec children options]\n  (let [form (impl/extract-form spec)\n        {:keys [type]} (parse/parse-spec form)]\n    (case type\n      :map (maybe-with-title {:type \"object\", :additionalProperties (impl/unwrap children)} spec options)\n      :set {:type \"array\", :uniqueItems true, :items (impl/unwrap children)}\n      :vector {:type \"array\", :items (impl/unwrap children)})))\n\n(defmethod accept-spec 'clojure.spec.alpha/every-kv [_ spec children options]\n  (maybe-with-title {:type \"object\", :additionalProperties (second children)} spec options))\n\n(defmethod accept-spec ::visitor/map-of [_ spec children options]\n  (maybe-with-title {:type \"object\", :additionalProperties (second children)} spec options))\n\n(defmethod accept-spec ::visitor/set-of [_ _ children _]\n  {:type \"array\", :items (impl/unwrap children), :uniqueItems true})\n\n(defmethod accept-spec ::visitor/vector-of [_ _ children _]\n  {:type \"array\", :items (impl/unwrap children)})\n\n(defmethod accept-spec 'clojure.spec.alpha/* [_ _ children _]\n  {:type \"array\" :items (impl/unwrap children)})\n\n(defmethod accept-spec 'clojure.spec.alpha/+ [_ _ children _]\n  {:type \"array\" :items (impl/unwrap children) :minItems 1})\n\n(defmethod accept-spec 'clojure.spec.alpha/? [_ _ children _]\n  {:type \"array\" :items (impl/unwrap children) :minItems 0})\n\n(defmethod accept-spec 'clojure.spec.alpha/alt [_ spec children options]\n  (maybe-with-title\n    {:anyOf children}\n    spec\n    options))\n\n(defmethod accept-spec 'clojure.spec.alpha/cat [_ spec children options]\n  (maybe-with-title\n    {:type \"array\"\n     :items {:anyOf children}}\n    spec\n    options))\n\n; &\n\n(defmethod accept-spec 'clojure.spec.alpha/tuple [_ _ children _]\n  {:type \"array\"\n   :items children})\n\n; keys*\n\n(defmethod accept-spec 'clojure.spec.alpha/nilable [_ _ children _]\n  {:oneOf [(impl/unwrap children) {:type \"null\"}]})\n\n;; this is just a function in clojure.spec?\n(defmethod accept-spec 'clojure.spec.alpha/int-in-range? [_ spec _ _]\n  (let [[_ minimum maximum _] (impl/strip-fn-if-needed spec)]\n    {:minimum minimum :maximum maximum}))\n\n(defmethod accept-spec ::visitor/spec [_ spec children _]\n  (let [[_ data] (impl/extract-form spec)\n        name (st/spec-name spec)\n        synthetic? (-> spec st/get-spec ::st/synthetic?)\n        json-schema-meta (impl/unlift-keys data \"json-schema\")\n        extra-info (-> (select-keys data [:description])\n                       (cond-> (and name (not synthetic?))\n                               (assoc :title (impl/qualified-name name))))]\n    (or (:json-schema data)\n        (merge (impl/unwrap children) extra-info json-schema-meta))))\n\n(defmethod accept-spec ::default [_ _ _ _]\n  {})\n"]}