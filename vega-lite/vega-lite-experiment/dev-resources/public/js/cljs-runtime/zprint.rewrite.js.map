{"version":3,"sources":["zprint/rewrite.cljc"],"mappings":"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","names":["zprint.rewrite/prewalk-subtree","p?","f","zloc","loc","rewrite-clj.zip/end?","temp__5733__auto__","n","rewrite-clj.zip/next","zprint.rewrite/prewalk","G__46796","G__46797","rewrite-clj.zip/replace","G__46798","rewrite-clj.zip/root","G__46799","rewrite-clj.zip/node","zprint.zutil/edn*","zprint.rewrite/get-sortable","nloc","cljs.core._EQ_","rewrite-clj.zip/tag","rewrite-clj.zip/string","next-element","rewrite-clj.zip/right","rewrite-clj.zip/down","zprint.rewrite/sort-val","dep-val","dep-seq","out","cljs.core.conj","dep-count","cljs.core/count","sorted-seq","cljs.core.sort_by","new-loc","last-loc","new-z","cljs.core/first","new-node","rewrite-clj.parser/parse-string","replaced-loc","clojure.zip/replace","cljs.core/next","rewrite-clj.zip/up","zprint.rewrite/sort-down","G__46827","zprint.rewrite/sort-dependencies","caller","options","new-dep","p1__46830#","rewrite-clj.zip/sexpr"],"sourcesContent":["(ns zprint.rewrite\n  (:require\n    clojure.string\n    [zprint.zutil :as zu :refer [string tag zreplace sexpr edn*]]\n    [rewrite-clj.parser :as p]\n    [rewrite-clj.node :as n]\n    [rewrite-clj.zip :as z]\n    #?@(:cljs [[rewrite-clj.zip.base :as zb] [rewrite-clj.zip.whitespace :as zw]\n               [rewrite-clj.zip.move :as zm] [rewrite-clj.zip.removez :as zr]\n               [rewrite-clj.zip.editz :as ze] clojure.zip])))\n\n;;\n;; No prewalk in rewrite-cljs, so we'll do it ourselves here\n;; for both environments, so that we can lean on the clj testing\n;; for cljs.\n;;\n\n(defn- prewalk-subtree\n  [p? f zloc]\n  (loop [loc zloc]\n    (if (z/end? loc)\n      loc\n      (if (p? loc)\n        (if-let [n (f loc)]\n          (recur (z/next n))\n          (recur (z/next loc)))\n        (recur (z/next loc))))))\n\n(defn ^:no-doc prewalk\n  [zloc p? f]\n  (z/replace zloc\n             (z/root (prewalk-subtree p?\n                                      f\n                                      ; Make a zipper whose root is zloc\n                                      (some-> zloc\n                                              z/node\n                                              edn*)))))\n\n\n;;\n;; # Routines to modify zippers inside of zprint\n;;\n\n(defn ^:no-doc get-sortable\n  \"Given a zloc, get something out of it that is sortable.\"\n  [zloc]\n  (loop [nloc zloc]\n    (if (= (z/tag nloc) :token)\n      (str (z/string nloc)\n           (let [next-element (z/right nloc)]\n             (if (= (z/tag next-element) :token) (z/string next-element) \"\")))\n      (recur (z/down nloc)))))\n\n(defn ^:no-doc sort-val\n  \"Sort the everything in the vector to the right of zloc.\"\n  [zloc]\n  (let [dep-val zloc\n        dep-seq (loop [nloc zloc\n                       out []]\n                  (if nloc (recur (z/right nloc) (conj out nloc)) out))\n        #_(println \"sort-val: count:\" (count dep-seq))\n        dep-count (count dep-seq)\n        sorted-seq (sort-by get-sortable dep-seq)\n        #_(println \"sort-val: dep-seq:\" (mapv get-sortable dep-seq))\n        #_(println \"sort-val: sorted-seq:\" (mapv get-sortable sorted-seq))]\n    (loop [nloc zloc\n           new-loc sorted-seq\n           last-loc nil]\n      #_(println \"sort-val: loop: before:\" (z/string nloc))\n      #_(when nloc (println \"sort-val: loop: n/tag:\" (n/tag (z/node nloc))))\n      #_(when new-loc\n          (println \"sort-val: loop: after:\" (n/string (z/node (first new-loc))))\n          (println \"sort-val: loop: n/tag:\" (n/tag (z/node (first new-loc)))))\n      (if new-loc\n        (let [new-z (first new-loc)\n              ; rewrite-cljs doesn't handle z/node for :uneval\n              ; so we will get an :uneval node a different way\n              new-node (if (= (z/tag new-z) :uneval)\n                         (p/parse-string (z/string new-z))\n                         (z/node new-z))\n              ; use clojure.zip for cljs, since the z/replace has\n              ; a built-in coerce, which doesn't work for an :uneval\n              replaced-loc #?(:clj (z/replace nloc new-node)\n                              :cljs (clojure.zip/replace nloc new-node))]\n          #_(println \"sort-val: loop: replaced-loc n/tag:\"\n                     (n/tag (z/node replaced-loc)))\n          (recur (z/right replaced-loc) (next new-loc) replaced-loc))\n        (z/up last-loc)))))\n\n(defn ^:no-doc sort-down\n  \"Do a down and a sort-val\"\n  [zloc]\n  (sort-val (z/down (z/right zloc))))\n\n(defn sort-dependencies\n  \"Reorder the dependencies in a project.clj file.\"\n  [caller options zloc]\n  (let [new-dep (prewalk zloc\n                         #(and (= (z/tag %1) :token)\n                               (= (z/sexpr %1) :dependencies))\n                         sort-down)]\n    new-dep))\n"]}