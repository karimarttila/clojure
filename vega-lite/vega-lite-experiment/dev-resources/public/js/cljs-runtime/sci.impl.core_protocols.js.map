{"version":3,"sources":["sci/impl/core_protocols.cljc"],"mappings":"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","names":["js/sci","js/sci.impl","js/sci.impl.core-protocols","js/sci.impl.core-protocols.-deref","method-table__4619__auto__","cljs.core.atom","prefer-table__4620__auto__","method-cache__4621__auto__","cached-hierarchy__4622__auto__","hierarchy__4623__auto__","cljs.core.get","fexpr__50058","cljs.core/MultiFn","cljs.core.symbol","sci.impl.core-protocols/-deref","sci.impl.types/type-impl","ref","methods","sci.impl.types/getMethods","fexpr__50059","cljs.core/deref","sci.impl.core-protocols/deref*","x","sci.impl.core-protocols/cljs-core-ns","sci.impl.vars/->SciNamespace","sci.impl.core-protocols/deref-protocol","sci.impl.vars.new_var","js/sci.impl.core-protocols.-swap!","fexpr__50061","sci.impl.core-protocols/-swap!","js/sci.impl.core-protocols.-reset!","fexpr__50069","sci.impl.core-protocols/-reset!","f","fexpr__50077","a1","fexpr__50078","a2","fexpr__50079","args","cljs.core.apply","v","fexpr__50083","cljs.core/swap!","cljs.core/reset!","var_args","args__4742__auto__","len__4736__auto__","i__4737__auto__","argseq__4743__auto__","cljs.core/IndexedSeq","sci.impl.core-protocols/swap!*","seq50086","G__50088","cljs.core/first","cljs.core/next","G__50089","self__4723__auto__","sci.impl.core-protocols/reset!*","sci.impl.core-protocols/swap-protocol","sci.impl.core-protocols/reset-protocol"],"sourcesContent":["(ns sci.impl.core-protocols\n  {:no-doc true}\n  (:refer-clojure :exclude [deref -deref -swap! -reset!])\n  (:require [sci.impl.types :as types]\n            [sci.impl.vars :as vars]))\n\n\n;;;; IDeref\n\n(defmulti #?(:clj deref :cljs -deref) types/type-impl)\n\n(defmethod #?(:clj deref :cljs -deref) :sci.impl.protocols/reified [ref]\n  (let [methods (types/getMethods ref)]\n    ((get methods #?(:clj 'deref :cljs '-deref)) ref)))\n\n(defmethod #?(:clj deref :cljs -deref) :default [ref]\n  (clojure.core/deref ref))\n\n(defn deref*\n  ([x]\n   #?(:clj (deref x)\n      :cljs (-deref x)))\n  #?(:clj\n     ([x & args]\n      (apply clojure.core/deref x args))))\n\n#?(:clj\n   (def clj-lang-ns (vars/->SciNamespace 'clojure.lang nil)))\n#?(:cljs\n   (def cljs-core-ns (vars/->SciNamespace 'cljs.core nil)))\n\n(def deref-protocol\n  #?(:clj\n     (vars/new-var\n      'clojure.lang.IDeref\n      {:class clojure.lang.IDeref\n       :methods #{deref}\n       :ns clj-lang-ns}\n      {:ns clj-lang-ns})\n     :cljs\n     (vars/new-var\n      'cljs.core.IDeref\n      {:methods #{-deref}\n       :ns cljs-core-ns}\n      {:ns cljs-core-ns})))\n\n;;;; end IDeref\n\n;;;; IAtom\n\n;; ;; You can use multiarity in multimethods\n;; (defmulti foo (fn [x & _] x))\n\n;; (defmethod foo :default [_ & _] \"DEFAULT VALUE DISPACHED\")\n\n;; ;; Like a standar multi-arity function\n;; (defmethod foo :bar\n;;   ([_ _] \"ONE ARGUMENT\")\n;;   ([_ _ _] \"TWO ARGUMENTs\")\n;;   ([_ _ _ _] \"THREE ARGUMENTs\")\n;;   ([_ _ _ _ & more] (cl-format nil \"~d ARGUMENTS\" (+ 3 (count more)))))\n\n(defmulti #?(:clj swap :cljs -swap!) types/type-impl)\n(defmulti #?(:clj reset :cljs -reset!) types/type-impl)\n#?(:clj (defmulti compareAndSet types/type-impl))\n#?(:clj (defmulti swapVals types/type-impl))\n#?(:clj (defmulti resetVals types/type-impl))\n\n;;;; Protocol methods\n\n(defmethod #?(:clj swap :cljs -swap!) :sci.impl.protocols/reified\n  ([ref f]\n   (let [methods (types/getMethods ref)]\n     ((get methods #?(:clj 'swap :cljs '-swap!)) ref f)))\n  ([ref f a1]\n   (let [methods (types/getMethods ref)]\n     ((get methods #?(:clj 'swap :cljs '-swap!)) ref f a1)))\n  ([ref f a1 a2]\n   (let [methods (types/getMethods ref)]\n     ((get methods #?(:clj 'swap :cljs '-swap!)) ref f a1 a2)))\n  ([ref f a1 a2 & args]\n   (let [methods (types/getMethods ref)]\n     (apply (get methods #?(:clj 'swap :cljs '-swap!)) ref f a1 a2 args))))\n\n(defmethod #?(:clj reset :cljs -reset!) :sci.impl.protocols/reified [ref v]\n  (let [methods (types/getMethods ref)]\n    ((get methods #?(:clj 'reset :cljs '-reset!)) ref v)))\n\n#?(:clj\n   (defmethod compareAndSet :sci.impl.protocols/reified [ref old new]\n     (let [methods (types/getMethods ref)]\n       ((get methods 'compareAndSet) ref old new))))\n\n#?(:clj\n   (defmethod swapVals :sci.impl.protocols/reified\n     ([ref f]\n      (let [methods (types/getMethods ref)]\n        ((get methods 'swapVals) ref f)))\n     ([ref f a1]\n      (let [methods (types/getMethods ref)]\n        ((get methods 'swapVals) ref f a1)))\n     ([ref f a1 a2]\n      (let [methods (types/getMethods ref)]\n        ((get methods 'swapVals) ref f a1 a2)))\n     ([ref f a1 a2 & args]\n      (let [methods (types/getMethods ref)]\n        (apply (get methods 'swapVals) ref f a1 a2 args)))))\n\n#?(:clj\n   (defmethod resetVals :sci.impl.protocols/reified [ref v]\n     (let [methods (types/getMethods ref)]\n       ((get methods 'resetVals) ref v))))\n\n;;;; Defaults\n\n(defmethod #?(:clj swap :cljs -swap!) :default [ref f & args]\n  ;; TODO: optimize arities\n  (apply clojure.core/swap! ref f args))\n\n(defmethod #?(:clj reset :cljs -reset!) :default [ref v]\n  (reset! ref v))\n\n#?(:clj\n   (defmethod compareAndSet :default [ref old new]\n     (compare-and-set! ref old new)))\n\n#?(:clj\n   (defmethod swapVals :default [ref & args]\n     (apply swap-vals! ref args)))\n\n#?(:clj\n   (defmethod resetVals :default [ref v]\n     (reset-vals! ref v)))\n\n;;;; Re-routing\n\n(defn swap!* [ref f & args]\n  ;; TODO: optimize arities - maybe test first how much this matters at all\n  ;; For CLJ I guess we can directly use the multimethods\n  (if args\n    (apply #?(:clj swap :cljs -swap!) ref f args)\n    (#?(:clj swap :cljs -swap!) ref f)))\n\n(defn reset!* [ref v]\n  (#?(:clj reset :cljs -reset!) ref v))\n\n#?(:clj\n   (defn compare-and-set!* [ref old new]\n     (compareAndSet ref old new)))\n\n#?(:clj\n   (defn swap-vals!* [ref f & args]\n     (apply swapVals ref f args)))\n\n#?(:clj\n   (defn reset-vals!* [ref v]\n     (resetVals ref v)))\n\n;;;; Protocol vars\n\n(def swap-protocol\n  #?(:clj\n     (vars/new-var\n      'clojure.lang.IAtom\n      {:class clojure.lang.IAtom\n       :methods #{swap, reset, compareAndSet}\n       :ns clj-lang-ns}\n      {:ns clj-lang-ns})\n     :cljs\n     (vars/new-var\n      'cljs.core.ISwap\n      {:methods #{-swap!}\n       :ns cljs-core-ns}\n      {:ns cljs-core-ns})))\n\n#?(:cljs\n   (def reset-protocol\n     (vars/new-var\n      'cljs.core.IReset\n      {:methods #{-reset!}\n       :ns cljs-core-ns}\n      {:ns cljs-core-ns})))\n\n#?(:clj\n   (def iatom2-protocol\n     (vars/new-var\n      'clojure.lang.IAtom2\n      {:class clojure.lang.IAtom2\n       :methods #{swap, reset, compareAndSet, swapVals, resetVals}\n       :ns clj-lang-ns}\n      {:ns clj-lang-ns})))\n\n;;;; end IAtom\n"]}