{"version":3,"sources":["sci/impl/parser/edamame.cljc"],"mappings":"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","names":["sci.impl.parser.edamame/edn-read","ctx","reader","tools-reader-opts","cljs.tools.reader.edn.read","sci.impl.parser.edamame/dispatch-macro?","ch","cljs.core/contains?","cljs.tools.reader.edn/read-token","sci.impl.parser.edamame/read-token","cljs.tools.reader.impl.commons/parse-symbol","sci.impl.parser.edamame/parse-symbol","this__4380__auto__","k__4381__auto__","this__4382__auto__","k51632","else__4383__auto__","G__51658","cljs.core/Keyword","line","column","cljs.core.get","__extmap","this__4399__auto__","f__4400__auto__","init__4401__auto__","cljs.core.reduce","ret__4402__auto__","p__51665","vec__51668","k__4403__auto__","cljs.core.nth","v__4404__auto__","this__4394__auto__","writer__4395__auto__","opts__4396__auto__","pr-pair__4397__auto__","keyval__4398__auto__","cljs.core/pr-sequential-writer","cljs.core.concat","cljs.core/PersistentVector","G__51631","cljs.core/RecordIter","cljs.core/-iterator","cljs.core/nil-iter","this__4378__auto__","__meta","this__4375__auto__","__hash","this__4384__auto__","cljs.core/count","this__4376__auto__","h__4238__auto__","coll__4377__auto__","cljs.core/hash-unordered-coll","this51633","other51634","cljs.core._EQ_","this__4389__auto__","k__4390__auto__","cljs.core.dissoc","cljs.core/-with-meta","cljs.core.into","cljs.core/not-empty","this__4387__auto__","k__4388__auto__","pred__51721","cljs.core/keyword-identical?","expr__51722","cljs.core.assoc","this__4392__auto__","cljs.core/seq","cljs.core/MapEntry","this__4379__auto__","this__4385__auto__","entry__4386__auto__","cljs.core/vector?","cljs.core/-nth","cljs.core/-conj","sci.impl.parser.edamame/Loc","this__4423__auto__","cljs.core/List","writer__4424__auto__","cljs.core/-write","G__51635","extmap__4419__auto__","G__51780","cljs.core/record?","sci.impl.parser.edamame/->Loc","sci.impl.parser.edamame/map->Loc","sci.impl.parser.edamame/location","sci.impl.parser.edamame/kw-identical?","kw","v","sci.impl.parser.edamame/parse-comment","cljs.tools.reader.reader-types/read-line","sci.impl.parser.edamame/whitespace?","c","and__4115__auto__","sci.impl.parser.edamame/skip-whitespace","_ctx","temp__5735__auto__","var_args","G__51848","sci.impl.parser.edamame/throw-reader","js/Error","msg","sci.impl.parser.edamame.throw_reader","data","loc","cljs.tools.reader.reader-types/get-column-number","l","cljs.tools.reader.reader-types/get-line-number","cljs.core.ex_info","cljs.core.merge","sci.impl.parser.edamame/non-match","cljs.core.symbol","sci.impl.parser.edamame/non-match?","sci.impl.parser.edamame/throw-eof-while-reading","G__51871","sci.impl.parser.edamame/parse-to-delimiter","delimiter","sci.impl.parser.edamame.parse_to_delimiter","into","opened","vals","cljs.core/transient","next-val","sci.impl.parser.edamame/parse-next","cond-splice?","G__51923","cljs.core/meta","cljs.core/persistent!","seq__51936","chunk__51937","count__51938","i__51939","cljs.core/chunked-seq?","c__4556__auto__","cljs.core/chunk-first","cljs.core/chunk-rest","cljs.core/first","cljs.core/next","cljs.core.conj_BANG_","sci.impl.parser.edamame/parse-list","cljs.core.apply","cljs.core/list","sci.impl.parser.edamame/read-regex-pattern","sb","js/goog.string.StringBuffer","sci.impl.parser.edamame/duplicate-keys-error","coll","seq","iter__4529__auto__","s__52032","cljs.core/LazySeq","c__4527__auto__","size__4528__auto__","b__52034","cljs.core/chunk-buffer","i__52033","vec__52038","cljs.core/chunk-append","cljs.core/chunk-cons","cljs.core/chunk","iter__52031","vec__52046","cljs.core/cons","cljs.core/rest","id","freq","cljs.core/frequencies","dups","duplicates","cljs.core/str","cljs.core.interpose","sci.impl.parser.edamame/throw-dup-keys","kind","ks","clojure.string/capitalize","cljs.core/name","sci.impl.parser.edamame/parse-set","start-loc","the-set","cljs.core/set","sci.impl.parser.edamame/parse-first-matching-condition","features","match","k","next-is-match?","map__52139","cljs.core/PROTOCOL_SENTINEL","cljs.core/hash-map","char","G__52159","G__52160","sci.impl.parser.edamame/parse-reader-conditional","opt","splice?","cljs.tools.reader.impl.utils/reader-conditional","cljs.core/fn?","G__52166","cljs.core.vary_meta","cljs.core/assoc","p1__52161#","G__52174","sci.impl.parser.edamame/get-auto-resolve","sci.impl.parser.edamame.get_auto_resolve","temp__5733__auto__","or__4126__auto__","G__52197","sci.impl.parser.edamame/auto-resolve","m","kns","sci.impl.parser.edamame.auto_resolve","sci.impl.parser.edamame/parse-namespaced-map","auto-resolved?","current-ns?","prefix","the-map","ns","f","resolved-ns","cljs.core/zipmap","cljs.tools.reader.impl.utils/namespace-keys","cljs.core/keys","cljs.core/vals","sci.impl.parser.edamame/parse-sharp","G__52199","pat","cljs.core/re-pattern","fn-expr","edamame.impl.read-fn/read-fn","suppress?","sym","readers","fexpr__52200","cljs.core/deref","cljs.reader/*tag-table*","sci.impl.parser.edamame/throw-odd-map","elements","cljs.tools.reader.impl.inspect.inspect","sci.impl.parser.edamame/parse-map","cljs.core/odd?","cljs.core.take_nth","cljs.core/distinct?","sci.impl.parser.edamame/parse-keyword","init-c","token","auto-resolve?","vec__52207","cljs.core.subs","token-ns","token-name","cljs.core.keyword","sci.impl.parser.edamame/dispatch","sharp?","G__52210","gensyms","cljs.core.atom","ret","sci.impl.parser.edamame.syntax-quote/syntax-quote","nc","expected","cljs.core.not_EQ_","map__52219","map__52335","map__52378","meta-val","val-val","cljs.core/merge","sci.impl.parser.edamame/desugar-meta","cljs.core/Symbol","sci.impl.parser.edamame/iobj?","obj","cljs.core/native-satisfies?","cljs.core/IWithMeta","G__52475","sci.impl.parser.edamame.parse_next","desugar","cljs.tools.reader.reader-types/peek-char","log?","buf","offset","cljs.tools.reader.reader-types/log-source*","iobj??","src","loc?","cljs.core/seq?","p1__52472#","G__52486","sci.impl.parser.edamame/string-reader","s","cljs.tools.reader.reader_types.indexing_push_back_reader","cljs.tools.reader.reader_types.string_push_back_reader","sci.impl.parser.edamame/parse-string","opts","src?","r","cljs.tools.reader.reader_types.source_logging_push_back_reader","sci.impl.parser.edamame/parse-string-all","sci.impl.parser.edamame/reader","x","string-reader","cljs.tools.reader.reader-types/string-reader","buf-len","pushback-reader","cljs.tools.reader.reader-types/PushbackReader","cljs.core.object_array","sci.impl.parser.edamame/get-line-number","sci.impl.parser.edamame/get-column-number","sci.impl.parser.edamame/source-logging-reader"],"sourcesContent":["(ns sci.impl.parser.edamame\n  \"This code is largely inspired by rewrite-clj(sc), so thanks to all\n  who contribured to those projects.\"\n  {:no-doc true}\n  (:require\n   #?(:clj  [clojure.tools.reader.edn :as edn]\n      :cljs [cljs.tools.reader.edn :as edn])\n   #?(:clj  [clojure.tools.reader.reader-types :as r]\n      :cljs [cljs.tools.reader.reader-types :as r])\n   #?(:clj  [clojure.tools.reader.impl.inspect :as i]\n      :cljs [cljs.tools.reader.impl.inspect :as i])\n   #?(:clj [clojure.tools.reader.impl.utils :refer [namespace-keys]]\n      :cljs [cljs.tools.reader.impl.utils :refer [reader-conditional namespace-keys]])\n   #?(:clj [clojure.tools.reader.impl.commons :as commons]\n      :cljs [cljs.tools.reader.impl.commons :as commons])\n   #?(:cljs [cljs.reader :refer [*tag-table*]])\n   [clojure.string :as str]\n   [edamame.impl.read-fn :refer [read-fn]]\n   [sci.impl.parser.edamame.syntax-quote :refer [syntax-quote]])\n  #?(:clj (:import [java.io Closeable]\n                   [clojure.tools.reader.reader_types SourceLoggingPushbackReader]))\n  #?(:cljs (:import [goog.string StringBuffer])))\n\n#?(:clj (set! *warn-on-reflection* true))\n\n;;;; tools.reader\n\n;; This is used for reading tokens (numbers, strings, symbols, chars,\n;; ##Inf). We're falling back on the EDN reader to handle this. Tried inlining\n;; it, but saw no significant performance gain.\n(defn edn-read [ctx #?(:cljs ^not-native reader :default reader)]\n  (let [tools-reader-opts (:tools.reader/opts ctx)]\n    (edn/read tools-reader-opts reader)))\n\n(defn dispatch-macro? [ch]\n  (contains? #{\\^  ;; deprecated\n               \\'\n               \\(\n               \\{\n               \\\"\n               \\!\n               \\_\n               \\?\n               \\:\n               \\#} ch))\n\n(def read-token #'edn/read-token)\n(def parse-symbol #'commons/parse-symbol)\n\n;;;; end tools.reader\n\n(defrecord Loc [line column])\n\n(defn location [#?(:cljs ^not-native reader :default reader)]\n  (->Loc\n   (r/get-line-number reader)\n   (r/get-column-number reader)))\n\n(defn kw-identical? [kw v]\n  (#?(:clj identical? :cljs keyword-identical?) kw v))\n\n(declare parse-next)\n\n(defn parse-comment\n  [#?(:cljs ^not-native reader :default reader)]\n  (r/read-line reader)\n  reader)\n\n#?(:cljs\n   (defn whitespace?\n     [c]\n     (and c (< -1 (.indexOf #js [\\return \\newline \\tab \\space \",\"] c)))))\n\n#?(:clj\n   (defmacro whitespace? [c]\n     `(and ~c (or (identical? ~c \\,)\n                  (Character/isWhitespace ~(with-meta c\n                                             {:tag 'java.lang.Character}))))))\n\n\n(defn skip-whitespace\n  \"Skips whitespace. Returns reader. If end of stream is reached, returns nil.\"\n  [_ctx #?(:cljs ^not-native reader :default reader)]\n  (loop []\n    (when-let [c (r/read-char reader)]\n      (if (whitespace? c)\n        (recur)\n        (do (r/unread reader c)\n            reader)))))\n\n(defn throw-reader\n  \"Throw reader exception, including line line/column. line/column is\n  read from the reader but it can be overriden by passing loc\n  optional parameter.\"\n  ([ctx #?(:cljs ^:not-native reader :default reader) msg]\n   (throw-reader ctx reader msg nil))\n  ([ctx #?(:cljs ^:not-native reader :default reader) msg data]\n   (throw-reader ctx reader msg data nil))\n  ([_ctx #?(:cljs ^:not-native reader :default reader) msg data loc]\n   (let [c (:column loc (r/get-column-number reader))\n         l (:line loc (r/get-line-number reader))]\n     (throw\n      (ex-info msg\n               (merge {:type :edamame/error\n                       :line l\n                       :column c} data))))))\n\n(def non-match (symbol \"non-match\"))\n\n(defn non-match? [v]\n  (identical? v non-match))\n\n(defn throw-eof-while-reading [ctx reader]\n  (throw-reader ctx reader \"EOF while reading\"))\n\n(defn parse-to-delimiter\n  ([ctx #?(:cljs ^not-native reader :default reader) delimiter]\n   (parse-to-delimiter ctx reader delimiter []))\n  ([ctx #?(:cljs ^not-native reader :default reader) delimiter into]\n   (let [line (r/get-line-number reader)\n         column (r/get-column-number reader)\n         opened (r/read-char reader)\n         ctx (-> ctx\n                 (assoc ::expected-delimiter delimiter)\n                 (assoc ::opened-delimiter {:char opened :line line :column column}))]\n     (loop [vals (transient into)]\n       (let [;; if next-val is uneval, we get back the expected delimiter...\n             next-val (parse-next ctx reader)\n             cond-splice? (some-> next-val meta ::cond-splice)]\n         (cond\n           (kw-identical? ::eof next-val)\n           (throw-reader ctx\n                         reader\n                         (str \"EOF while reading, expected \" delimiter \" to match \" opened \" at [\" line \",\" column \"]\")\n                         {:edamame/expected-delimiter (str delimiter)\n                          :edamame/opened-delimiter (str opened)})\n           (kw-identical? ::expected-delimiter next-val)\n           (persistent! vals)\n           cond-splice? (do (doseq [v next-val]\n                              (conj! vals v))\n                            (recur vals))\n           (non-match? next-val) (recur vals)\n           :else\n           (recur (conj! vals next-val))))))))\n\n(defn parse-list [ctx #?(:cljs ^not-native reader :default reader)]\n  (apply list (parse-to-delimiter ctx reader \\))))\n\n(defn read-regex-pattern\n  \"Modeled after tools.reader/read-regex.\"\n  [ctx #?(:cljs ^not-native reader :default reader)]\n  (r/read-char reader) ;; ignore leading double-quote\n  (let [sb #?(:clj (StringBuilder.)\n              :cljs (StringBuffer.))]\n    (loop [ch (r/read-char reader)]\n      (if (identical? \\\" ch)\n        #?(:clj (str sb)\n           :cljs (str sb))\n        (if (nil? ch)\n          (throw-reader ctx reader \"Error while parsing regex\")\n          (do\n            (.append sb ch )\n            (when (identical? \\\\ ch)\n              (let [ch (r/read-char reader)]\n                (when (nil? ch)\n                  (throw-reader ctx reader \"Error while parsing regex\"))\n                (.append sb ch)))\n            (recur (r/read-char reader))))))))\n\n(defn- duplicate-keys-error [msg coll]\n  ;; https://github.com/clojure/tools.reader/blob/97d5dac9f5e7c04d8fe6c4a52cd77d6ced560d76/src/main/cljs/cljs/tools/reader/impl/errors.cljs#L233\n  (letfn [(duplicates [seq]\n            (for [[id freq] (frequencies seq)\n                  :when (> freq 1)]\n              id))]\n    (let [dups (duplicates coll)]\n      (apply str msg\n             (when (> (count dups) 1) \"s\")\n             \": \" (interpose \", \" dups)))))\n\n(defn throw-dup-keys\n  [ctx #?(:cljs ^not-native reader :default reader) loc kind ks]\n  (throw-reader\n   ctx reader\n   (duplicate-keys-error\n    (str (str/capitalize (name kind)) \" literal contains duplicate key\")\n    ks)\n   nil\n   loc))\n\n(defn parse-set\n  [ctx #?(:cljs ^not-native reader :default reader)]\n  (let [start-loc (location reader)\n        coll (parse-to-delimiter ctx reader \\})\n        the-set (set coll)]\n    (when-not (= (count coll) (count the-set))\n      (throw-dup-keys ctx reader start-loc :set coll))\n    the-set))\n\n(defn parse-first-matching-condition [ctx #?(:cljs ^not-native reader :default reader)]\n  (let [features (:features ctx)]\n    (loop [match non-match]\n      (let [k (parse-next ctx reader)]\n        (if (kw-identical? k ::expected-delimiter)\n          match\n          (let [next-is-match? (and (non-match? match)\n                                    (or (contains? features k)\n                                        (kw-identical? k :default)))]\n            (if next-is-match?\n              (let [match (parse-next ctx reader)\n                    ctx (assoc ctx ::suppress true)]\n                (loop []\n                  (let [next-val (parse-next ctx reader)]\n                    (when-not (kw-identical? ::expected-delimiter\n                                             next-val)\n                      (if (kw-identical? ::eof next-val)\n                        (let [delimiter (::expected-delimiter ctx)\n                              {:keys [:line :column :char]} (::opened-delimiter ctx)]\n                          (throw-reader ctx\n                                        reader\n                                        (str \"EOF while reading, expected \" delimiter \" to match \" char \" at [\" line \",\" column \"]\")\n                                        {:edamame/expected-delimiter (str delimiter)\n                                         :edamame/opened-delimiter (str char)}))\n                        (recur)))))\n                match)\n              (do\n                ;; skip over next val and try next key\n                (parse-next (assoc ctx ::suppress true)\n                            reader)\n                (recur match)))))))))\n\n(defn parse-reader-conditional [ctx #?(:cljs ^not-native reader :default reader)]\n  (skip-whitespace ctx reader)\n  (let [opt (:read-cond ctx)\n        splice? (= \\@ (r/peek-char reader))]\n    (when splice? (r/read-char reader))\n    (skip-whitespace ctx reader)\n    (cond (kw-identical? :preserve opt)\n          (reader-conditional (parse-next ctx reader) splice?)\n          (fn? opt)\n          (opt (vary-meta\n                (parse-next ctx reader)\n                assoc :edamame/read-cond-splicing splice?))\n          :else\n          (let [line (r/get-line-number reader)\n                column (r/get-column-number reader)\n                opened (r/read-char reader)\n                ctx (-> ctx\n                        (assoc ::expected-delimiter \\))\n                        (assoc ::opened-delimiter {:char opened :line line :column column}))\n                match (parse-first-matching-condition ctx reader)]\n            (cond (non-match? match) reader\n                  splice? (vary-meta match\n                                     #(assoc % ::cond-splice true))\n                  :else match)))))\n\n(defn get-auto-resolve\n  ([ctx reader next-val]\n   (get-auto-resolve ctx reader next-val nil))\n  ([ctx reader next-val msg]\n   (if-let [v (:auto-resolve ctx)]\n     v\n     (throw-reader ctx reader\n                   (or msg \"Use `:auto-resolve` to resolve aliases.\")\n                   {:expr (str \":\" next-val)}))))\n\n(defn auto-resolve\n  \"Returns namespace for given alias.\"\n  ([ctx m kns reader next-val] (auto-resolve ctx m kns reader next-val nil))\n  ([ctx m kns reader next-val msg]\n   (if-let [kns (m kns)]\n     kns\n     (throw-reader ctx reader\n                   (or msg (str \"Alias `\" (symbol kns) \"` not found in `:auto-resolve`\"))\n                   {:expr (str \":\" next-val)}))))\n\n(defn parse-namespaced-map [ctx #?(:cljs ^not-native reader :default reader)]\n  (let [auto-resolved? (when (identical? \\: (r/peek-char reader))\n                         (r/read-char reader)\n                         true)\n        current-ns? (when auto-resolved?\n                      (identical? \\{ (r/peek-char reader)))\n        prefix (if auto-resolved?\n                 (when-not current-ns?\n                   (edn-read ctx reader))\n                 (edn-read ctx reader))\n        the-map (parse-next ctx reader)]\n    (if auto-resolved?\n      (let [ns (if current-ns? :current (symbol (name prefix)))\n            f (get-auto-resolve ctx reader ns)\n            resolved-ns (auto-resolve ctx f ns reader prefix)]\n        (zipmap (namespace-keys (str resolved-ns) (keys the-map))\n                (vals the-map)))\n      (let [resolved-ns (name prefix)]\n        (zipmap (namespace-keys resolved-ns (keys the-map))\n                (vals the-map))))))\n\n(defn parse-sharp\n  [ctx #?(:cljs ^not-native reader :default reader)]\n  (let [c (r/peek-char reader)]\n    (case c\n      nil (throw-reader ctx reader (str \"Unexpected EOF.\"))\n      \\\" (let [pat (read-regex-pattern ctx reader)]\n           (re-pattern pat))\n      \\( (let [fn-expr (parse-next ctx reader)]\n           (read-fn fn-expr))\n      \\' (do\n           (r/read-char reader) ;; ignore quote\n           (let [next-val (parse-next ctx reader)]\n             (when (kw-identical? ::eof next-val)\n               (throw-eof-while-reading ctx reader))\n             (list 'var next-val)))\n      \\= (do\n           (r/read-char reader) ;; ignore =\n           (let [next-val (parse-next ctx reader)]\n             (list 'read-eval next-val)))\n      \\{ (parse-set ctx reader)\n      \\_ (do\n           (r/read-char reader) ;; read _\n           (parse-next ctx reader) ;; ignore next form\n           reader)\n      \\? (do\n           (when-not (:read-cond ctx)\n             (throw-reader\n              ctx reader\n              (str \"Conditional read not allowed.\")))\n           (r/read-char reader) ;; ignore ?\n           (parse-reader-conditional ctx reader))\n      \\: (do\n           (r/read-char reader) ;; ignore :\n           (parse-namespaced-map ctx reader))\n      \\! (do\n           (parse-comment reader)\n           reader)\n      ;; catch-all\n      (if (dispatch-macro? c)\n        (do (r/unread reader \\#)\n            (edn-read ctx reader))\n        ;; reader tag\n        (let [suppress? (::suppress ctx)]\n          (if suppress?\n            (do\n              ;; read symbol\n              (parse-next ctx reader)\n              ;; read form\n              (parse-next ctx reader))\n            (let [sym (parse-next ctx reader)\n                  data (parse-next ctx reader)\n                  f (or (when-let [readers (:readers ctx)]\n                          (readers sym))\n                        #?(:clj (default-data-readers sym)\n                           :cljs (@*tag-table* sym)))]\n              (if f (f data)\n                  (throw (new #?(:clj Exception :cljs js/Error)\n                              (str \"No reader function for tag \" sym)))))))))))\n\n(defn throw-odd-map\n  [ctx #?(:cljs ^not-native reader :default reader) loc elements]\n  (throw-reader ctx reader\n                (str\n                 \"The map literal starting with \"\n                 (i/inspect (first elements))\n                 \" contains \"\n                 (count elements)\n                 \" form(s). Map literals must contain an even number of forms.\")\n                nil\n                loc))\n\n(defn parse-map\n  [ctx #?(:cljs ^not-native reader :default reader)]\n  (let [start-loc (location reader)\n        elements (parse-to-delimiter ctx reader \\})\n        c (count elements)]\n    (when (pos? c)\n      (when (odd? c)\n        (throw-odd-map ctx reader start-loc elements))\n      (let [ks (take-nth 2 elements)]\n        (when-not (apply distinct? ks)\n          (throw-dup-keys ctx reader start-loc :map ks))))\n    (apply hash-map elements)))\n\n(defn parse-keyword [ctx #?(:cljs ^not-native reader :default reader)]\n  (r/read-char reader) ;; ignore :\n  (let [init-c (r/read-char reader)]\n    (when (whitespace? init-c)\n      (throw-reader ctx reader (str \"Invalid token: :\")))\n    (let [^String token (read-token reader :keyword init-c)\n          auto-resolve? (identical? \\: (.charAt token 0))]\n      (if auto-resolve?\n        (let [token (if auto-resolve? (subs token 1) token)\n              [token-ns token-name] (parse-symbol token)]\n          (if token-ns\n            (let [f (get-auto-resolve ctx reader token)\n                  kns (auto-resolve ctx f (symbol token-ns) reader token-ns)]\n              (keyword (str kns) token-name))\n            ;; resolve current ns\n            (let [f (get-auto-resolve ctx reader token \"Use `:auto-resolve` + `:current` to resolve current namespace.\")\n                  kns (auto-resolve ctx f :current reader token \"Use `:auto-resolve` + `:current` to resolve current namespace.\")]\n              (keyword (str kns) token-name))))\n        (keyword token)))))\n\n(defn dispatch\n  [ctx #?(:cljs ^not-native reader :default reader) c]\n  (let [sharp? (= \\# c)]\n    (if sharp? (do\n                 (r/read-char reader) ;; ignore sharp\n                 (parse-sharp ctx reader))\n        (case c\n          nil ::eof\n          \\@ (do (r/read-char reader) ;; skip @\n                 (let [next-val (parse-next ctx reader)]\n                   (list 'clojure.core/deref next-val)))\n          \\' (do\n               (r/read-char reader) ;; skip '\n               (let [next-val (parse-next ctx reader)]\n                 (when (kw-identical? ::eof next-val)\n                   (throw-eof-while-reading ctx reader))\n                 (list 'quote next-val)))\n          \\` (do\n               (r/read-char reader) ;; skip `\n               (let [next-val (parse-next ctx reader)\n                     gensyms (atom {})\n                     ctx (assoc ctx :gensyms gensyms)\n                     ret (syntax-quote ctx reader next-val)]\n                 ret))\n          \\~ (do\n               (r/read-char reader) ;; skip `\n               (let [nc (r/peek-char reader)]\n                 (if (identical? nc \\@)\n                   (do\n                     (r/read-char reader) ;; ignore @\n                     (let [next-val (parse-next ctx reader)]\n                       (list 'clojure.core/unquote-splicing next-val)))\n                   (let [next-val (parse-next ctx reader)]\n                     (list 'clojure.core/unquote next-val)))))\n          \\( (parse-list ctx reader)\n          \\[ (parse-to-delimiter ctx reader \\])\n          \\{ (parse-map ctx reader)\n          (\\} \\] \\)) (let [expected (::expected-delimiter ctx)]\n                       (if (not= expected c)\n                         (let [loc (location reader)]\n                           (r/read-char reader) ;; ignore unexpected\n                           ;; delimiter to be able to\n                           ;; continue reading, fix for\n                           ;; babashka socket REPL\n                           (throw-reader ctx reader\n                                         (str \"Unmatched delimiter: \" c\n                                              (when expected\n                                                (str \", expected: \" expected\n                                                     (when-let [{:keys [:line :column :char]} (::opened-delimiter ctx)]\n                                                       (str \" to match \" char \" at \" [line column])))))\n                                         ctx\n                                         loc))\n                         (do\n                           ;; read delimiter\n                           (r/read-char reader)\n                           ::expected-delimiter)))\n          \\; (parse-comment reader)\n          \\^ (do\n               (r/read-char reader) ;; ignore ^\n               (let [meta-val (parse-next ctx reader true)\n                     val-val (vary-meta (parse-next ctx reader)\n                                        merge meta-val)]\n                 val-val))\n          \\: (parse-keyword ctx reader)\n          (edn-read ctx reader)))))\n\n(defn desugar-meta\n  \"Resolves syntactical sugar in metadata\" ;; could be combined with some other desugar?\n  ([f]\n   (cond\n     (keyword? f) {f true}\n     (symbol? f)  {:tag f}\n     (string? f)  {:tag f}\n     :else        f)))\n\n(defn iobj? [obj]\n  #?(:clj\n     (instance? clojure.lang.IObj obj)\n     :cljs (satisfies? IWithMeta obj)))\n\n(defn parse-next\n  ([ctx reader] (parse-next ctx reader nil))\n  ([ctx reader desugar]\n   (if-let [c (and (skip-whitespace ctx reader)\n                   (r/peek-char reader))]\n     (let [loc (location reader)\n           log? (:source ctx)\n           buf (fn [] (str (:buffer @#?(:clj (.source-log-frames ^SourceLoggingPushbackReader reader)\n                                        :cljs (.-frames reader)))))\n           offset (when log? (count (buf)))\n           obj (if log?\n                 #?(:clj (r/log-source reader (dispatch ctx reader c))\n                    :cljs (r/log-source* reader #(dispatch ctx reader c)))\n                 (dispatch ctx reader c))]\n       (if (identical? reader obj)\n         (recur ctx reader desugar)\n         (if (kw-identical? ::expected-delimiter obj)\n           obj\n           (let [iobj?? (iobj? obj)\n                 src (when log?\n                       (.trim (subs (buf) offset)))\n                 loc? (or (and iobj??\n                               (or (symbol? obj)\n                                   (seq? obj))))\n                 line (when loc? (:line loc))\n                 column (when loc? (:column loc))\n                 obj (if desugar (desugar-meta obj) obj)\n                 obj (cond loc? (vary-meta obj\n                                           #(cond-> %\n                                              ;; Note: using 3-arity of assoc, because faster\n                                              loc? (-> (assoc :line line)\n                                                       (assoc :column column))\n                                              src (assoc :source src)))\n                           :else obj)]\n             obj))))\n     ::eof)))\n\n(defn string-reader\n  \"Create reader for strings.\"\n  [s]\n  (r/indexing-push-back-reader\n   (r/string-push-back-reader s)))\n\n(defn parse-string [s opts]\n  (let [src? (:source opts)\n        r (if src? (r/source-logging-push-back-reader s)\n              (string-reader s))\n        ctx (assoc opts ::expected-delimiter nil)\n        v (parse-next ctx r)]\n    (if (kw-identical? ::eof v) nil v)))\n\n(defn parse-string-all [s opts]\n  (let [^Closeable r (string-reader s)\n        ctx (assoc opts ::expected-delimiter nil)]\n    (loop [ret (transient [])]\n      (let [next-val (parse-next ctx r)]\n        (if (kw-identical? ::eof next-val)\n          (persistent! ret)\n          (recur (conj! ret next-val)))))))\n\n(defn reader\n  [x]\n  #?(:clj (r/indexing-push-back-reader (r/push-back-reader x))\n     :cljs (let [string-reader (r/string-reader x)\n                 buf-len 1\n                 pushback-reader (r/PushbackReader. string-reader\n                                                    (object-array buf-len)\n                                                    buf-len buf-len)]\n             (r/indexing-push-back-reader pushback-reader))))\n\n(defn get-line-number [reader]\n  (r/get-line-number reader))\n\n(defn get-column-number [reader]\n  (r/get-column-number reader))\n\n(defn source-logging-reader\n  [x]\n  #?(:clj (r/source-logging-push-back-reader (r/push-back-reader x))\n     :cljs (let [string-reader (r/string-reader x)\n                 buf-len 1\n                 pushback-reader (r/PushbackReader. string-reader\n                                                    (object-array buf-len)\n                                                    buf-len buf-len)]\n             (r/source-logging-push-back-reader pushback-reader))))\n\n;;;; Scratch\n\n(comment\n  )\n"]}