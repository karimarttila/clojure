{
"version":3,
"file":"goog.events.events.js",
"lineCount":378,
"mappings":"AAqDAA,IAAA,CAAKC,OAAL,CAAa,aAAb,CAAA;AACAD,IAAA,CAAKC,OAAL,CAAa,mCAAb,CAAA;AACAD,IAAA,CAAKC,OAAL,CAAa,iBAAb,CAAA;AACAD,IAAA,CAAKC,OAAL,CAAa,4BAAb,CAAA;AAEAD,IAAA,CAAKE,cAAL,CAAoB,yBAApB,CAAA;AACAF,IAAA,CAAKE,cAAL,CAAoB,0BAApB,CAAA;AACAF,IAAA,CAAKG,OAAL,CAAa,cAAb,CAAA;AACAH,IAAA,CAAKG,OAAL,CAAa,+BAAb,CAAA;AACAH,IAAA,CAAKG,OAAL,CAAa,0BAAb,CAAA;AACAH,IAAA,CAAKG,OAAL,CAAa,4BAAb,CAAA;AACAH,IAAA,CAAKG,OAAL,CAAa,wBAAb,CAAA;AACAH,IAAA,CAAKG,OAAL,CAAa,yBAAb,CAAA;AAMAH,IAAA,CAAKI,MAAL,CAAYC,GAAZ;AAMAL,IAAA,CAAKI,MAAL,CAAYE,cAAZ;AAQAN,IAAA,CAAKI,MAAL,CAAYG,kBAAZ,GAAiC,aAAjC,IAAmDC,IAAA,CAAKC,MAAL,EAAnD,GAAmE,GAAnE,GAA0E,CAA1E;AAQAT,IAAA,CAAKI,MAAL,CAAYM,SAAZ,GAAwB,IAAxB;AAWAV,IAAA,CAAKI,MAAL,CAAYO,YAAZ,GAA2B,EAA3B;AAMAX,IAAA,CAAKI,MAAL,CAAYQ,qBAAZ,GAAoC,CAKlCC,aAAc,CALoB,EAWlCC,eAAgB,CAXkB,EAgBlCC,GAAI,CAhB8B,CAApC;AAwBAf,IAAA,CAAKI,MAAL,CAAYY,uBAAZ,GACIhB,IAAA,CAAKiB,MAAL,CAAY,qCAAZ,EAAmD,CAAnD,CADJ;AAQAjB,IAAA,CAAKI,MAAL,CAAYc,sBAAZ,GAAqC,CAArC;AAyBAlB,IAAA,CAAKI,MAAL,CAAYe,MAAZ,GAAqBC,QAAQ,CAACC,GAAD,EAAMC,IAAN,EAAYC,QAAZ,EAAsBC,WAAtB,EAAmCC,WAAnC,CAAgD;AAC3E,MAAID,WAAJ,IAAmBA,WAAnB,CAA+BE,IAA/B;AACE,WAAO1B,IAAA,CAAKI,MAAL,CAAYuB,UAAZ,CACHN,GADG,EACEC,IADF,EACQC,QADR,EACkBC,WADlB,EAC+BC,WAD/B,CAAP;AADF;AAIA,MAAIzB,IAAA,CAAK4B,OAAL,CAAaN,IAAb,CAAJ,CAAwB;AACtB,SAAK,IAAIO,IAAI,CAAb,EAAgBA,CAAhB,GAAoBP,IAApB,CAAyBQ,MAAzB,EAAiCD,CAAA,EAAjC;AACE7B,UAAA,CAAKI,MAAL,CAAYe,MAAZ,CAAmBE,GAAnB,EAAwBC,IAAA,CAAKO,CAAL,CAAxB,EAAiCN,QAAjC,EAA2CC,WAA3C,EAAwDC,WAAxD,CAAA;AADF;AAGA,WAAO,IAAP;AAJsB;AAOxBF,UAAA,GAAWvB,IAAA,CAAKI,MAAL,CAAY2B,YAAZ,CAAyBR,QAAzB,CAAX;AACA,MAAIvB,IAAA,CAAKI,MAAL,CAAY4B,UAAZ,CAAuBC,eAAvB,CAAuCZ,GAAvC,CAAJ,CAAiD;AAC/C,QAAIa,UACAlC,IAAA,CAAKmC,QAAL,CAAcX,WAAd,CAAA,GAA6B,CAAC,CAACA,WAAD,CAAaU,OAA3C,GAAqD,CAAC,CAACV,WAD3D;AAEA,WAAOH,GAAA,CAAIF,MAAJ,CACyCG,IADzC,EACgDC,QADhD,EAC0DW,OAD1D,EAEHT,WAFG,CAAP;AAH+C,GAAjD;AAOE,WAAOzB,IAAA,CAAKI,MAAL,CAAYgC,OAAZ,CAC0Bf,GAD1B,EACgCC,IADhC,EACsCC,QADtC,EAEY,KAFZ,EAEmBC,WAFnB,EAEgCC,WAFhC,CAAP;AAPF;AAb2E,CAA7E;AA+CAzB,IAAA,CAAKI,MAAL,CAAYgC,OAAZ,GAAsBC,QAAQ,CAC1BhB,GAD0B,EACrBC,IADqB,EACfC,QADe,EACLe,QADK,EACKd,WADL,EACkBC,WADlB,CAC+B;AAC3D,MAAI,CAACH,IAAL;AACE,UAAM,IAAIiB,KAAJ,CAAU,oBAAV,CAAN;AADF;AAIA,MAAIL,UACAlC,IAAA,CAAKmC,QAAL,CAAcX,WAAd,CAAA,GAA6B,CAAC,CAACA,WAAD,CAAaU,OAA3C,GAAqD,CAAC,CAACV,WAD3D;AAEA,MAAIU,OAAJ,IAAe,CAAClC,IAAD,CAAMI,MAAN,CAAaoC,cAAb,CAA4BC,qBAA3C;AACE,QAAIzC,IAAJ,CAASI,MAAT,CAAgBY,uBAAhB,IACIhB,IADJ,CACSI,MADT,CACgBQ,qBADhB,CACsCC,YADtC,CACoD;AAClDb,UAAA,CAAK0C,OAAL,CAAaC,IAAb,CAAkB,4CAAlB,CAAA;AACA,aAAO,IAAP;AAFkD,KADpD;AAIO,UACH3C,IADG,CACEI,MADF,CACSY,uBADT,IAEHhB,IAFG,CAEEI,MAFF,CAESQ,qBAFT,CAE+BE,cAF/B;AAGL,eAAO,IAAP;AAHK;AAJP;AADF;AAYA,MAAI8B,cAAc5C,IAAA,CAAKI,MAAL,CAAYyC,eAAZ,CAA4BxB,GAA5B,CAAlB;AACA,MAAI,CAACuB,WAAL;AACEvB,OAAA,CAAIrB,IAAJ,CAASI,MAAT,CAAgBG,kBAAhB,CAAA,GAAsCqC,WAAtC,GACI,IAAI5C,IAAJ,CAASI,MAAT,CAAgB0C,WAAhB,CAA4BzB,GAA5B,CADJ;AADF;AAKA,MAAI0B,cACAH,WAAA,CAAYI,GAAZ,CAAgB1B,IAAhB,EAAsBC,QAAtB,EAAgCe,QAAhC,EAA0CJ,OAA1C,EAAmDT,WAAnD,CADJ;AAKA,MAAIsB,WAAJ,CAAgBE,KAAhB;AACE,WAAOF,WAAP;AADF;AAIA,MAAIE,QAAQjD,IAAA,CAAKI,MAAL,CAAY8C,QAAZ,EAAZ;AACAH,aAAA,CAAYE,KAAZ,GAAoBA,KAApB;AAEAA,OAAA,CAAM5B,GAAN,GAAYA,GAAZ;AACA4B,OAAA,CAAM1B,QAAN,GAAiBwB,WAAjB;AAGA,MAAI1B,GAAJ,CAAQ8B,gBAAR,CAA0B;AAExB,QAAI,CAACnD,IAAD,CAAMI,MAAN,CAAaoC,cAAb,CAA4BY,cAAhC;AACE5B,iBAAA,GAAcU,OAAd;AADF;AAIA,QAAIV,WAAJ,KAAoB6B,SAApB;AAA+B7B,iBAAA,GAAc,KAAd;AAA/B;AACAH,OAAA,CAAI8B,gBAAJ,CAAqB7B,IAAA,CAAKgC,QAAL,EAArB,EAAsCL,KAAtC,EAA6CzB,WAA7C,CAAA;AAPwB,GAA1B;AAQO,QAAIH,GAAJ,CAAQkC,WAAR;AAKLlC,SAAA,CAAIkC,WAAJ,CAAgBvD,IAAA,CAAKI,MAAL,CAAYoD,YAAZ,CAAyBlC,IAAA,CAAKgC,QAAL,EAAzB,CAAhB,EAA2DL,KAA3D,CAAA;AALK;AAMA,UAAI5B,GAAJ,CAAQoC,WAAR,IAAuBpC,GAAvB,CAA2BqC,cAA3B,CAA2C;AAIhD1D,YAAA,CAAK0C,OAAL,CAAaiB,MAAb,CACIrC,IADJ,KACa,QADb,EACuB,wCADvB,CAAA;AAEAD,WAAA,CAAIoC,WAAJ,CAAgBR,KAAhB,CAAA;AANgD,OAA3C;AAQL,cAAM,IAAIV,KAAJ,CAAU,mDAAV,CAAN;AARK;AANA;AARP;AAyBAvC,MAAA,CAAKI,MAAL,CAAYc,sBAAZ,EAAA;AACA,SAAO6B,WAAP;AAnE2D,CAD7D;AA4EA/C,IAAA,CAAKI,MAAL,CAAY8C,QAAZ,GAAuBU,QAAQ,EAAG;AAChC,MAAIC,wBAAwB7D,IAAxB6D,CAA6BzD,MAA7ByD,CAAoCC,mBAAxC;AAEA,MAAIC,IACA/D,IAAA,CAAKI,MAAL,CAAYoC,cAAZ,CAA2BC,qBAA3B,GAAmD,QAAQ,CAACuB,WAAD,CAAc;AACvE,WAAOH,qBAAA,CAAsBI,IAAtB,CAA2BF,CAA3B,CAA6B1C,GAA7B,EAAkC0C,CAAlC,CAAoCxC,QAApC,EAA8CyC,WAA9C,CAAP;AADuE,GAAzE,GAEI,QAAQ,CAACA,WAAD,CAAc;AACxB,QAAIE,IAAIL,qBAAA,CAAsBI,IAAtB,CAA2BF,CAA3B,CAA6B1C,GAA7B,EAAkC0C,CAAlC,CAAoCxC,QAApC,EAA8CyC,WAA9C,CAAR;AAOA,QAAI,CAACE,CAAL;AAAQ,aAAOA,CAAP;AAAR;AARwB,GAH9B;AAaA,SAAOH,CAAP;AAhBgC,CAAlC;AA6CA/D,IAAA,CAAKI,MAAL,CAAYuB,UAAZ,GAAyBwC,QAAQ,CAC7B9C,GAD6B,EACxBC,IADwB,EAClBC,QADkB,EACRC,WADQ,EACKC,WADL,CACkB;AACjD,MAAIzB,IAAA,CAAK4B,OAAL,CAAaN,IAAb,CAAJ,CAAwB;AACtB,SAAK,IAAIO,IAAI,CAAb,EAAgBA,CAAhB,GAAoBP,IAApB,CAAyBQ,MAAzB,EAAiCD,CAAA,EAAjC;AACE7B,UAAA,CAAKI,MAAL,CAAYuB,UAAZ,CAAuBN,GAAvB,EAA4BC,IAAA,CAAKO,CAAL,CAA5B,EAAqCN,QAArC,EAA+CC,WAA/C,EAA4DC,WAA5D,CAAA;AADF;AAGA,WAAO,IAAP;AAJsB;AAOxBF,UAAA,GAAWvB,IAAA,CAAKI,MAAL,CAAY2B,YAAZ,CAAyBR,QAAzB,CAAX;AACA,MAAIvB,IAAA,CAAKI,MAAL,CAAY4B,UAAZ,CAAuBC,eAAvB,CAAuCZ,GAAvC,CAAJ,CAAiD;AAC/C,QAAIa,UACAlC,IAAA,CAAKmC,QAAL,CAAcX,WAAd,CAAA,GAA6B,CAAC,CAACA,WAAD,CAAaU,OAA3C,GAAqD,CAAC,CAACV,WAD3D;AAEA,WAAOH,GAAA,CAAIM,UAAJ,CACyCL,IADzC,EACgDC,QADhD,EAC0DW,OAD1D,EAEHT,WAFG,CAAP;AAH+C,GAAjD;AAOE,WAAOzB,IAAA,CAAKI,MAAL,CAAYgC,OAAZ,CAC0Bf,GAD1B,EACgCC,IADhC,EACsCC,QADtC,EAEY,IAFZ,EAEkBC,WAFlB,EAE+BC,WAF/B,CAAP;AAPF;AATiD,CADnD;AAuCAzB,IAAA,CAAKI,MAAL,CAAYgE,iBAAZ,GAAgCC,QAAQ,CACpChD,GADoC,EAC/BiD,OAD+B,EACtB/C,QADsB,EACZgD,QADY,EACF9C,WADE,CACW;AACjD6C,SAAA,CAAQnD,MAAR,CAAeE,GAAf,EAAoBE,QAApB,EAA8BgD,QAA9B,EAAwC9C,WAAxC,CAAA;AADiD,CADnD;AAuBAzB,IAAA,CAAKI,MAAL,CAAYoE,QAAZ,GAAuBC,QAAQ,CAACpD,GAAD,EAAMC,IAAN,EAAYC,QAAZ,EAAsBC,WAAtB,EAAmCC,WAAnC,CAAgD;AAC7E,MAAIzB,IAAA,CAAK4B,OAAL,CAAaN,IAAb,CAAJ,CAAwB;AACtB,SAAK,IAAIO,IAAI,CAAb,EAAgBA,CAAhB,GAAoBP,IAApB,CAAyBQ,MAAzB,EAAiCD,CAAA,EAAjC;AACE7B,UAAA,CAAKI,MAAL,CAAYoE,QAAZ,CAAqBnD,GAArB,EAA0BC,IAAA,CAAKO,CAAL,CAA1B,EAAmCN,QAAnC,EAA6CC,WAA7C,EAA0DC,WAA1D,CAAA;AADF;AAGA,WAAO,IAAP;AAJsB;AAMxB,MAAIS,UACAlC,IAAA,CAAKmC,QAAL,CAAcX,WAAd,CAAA,GAA6B,CAAC,CAACA,WAAD,CAAaU,OAA3C,GAAqD,CAAC,CAACV,WAD3D;AAGAD,UAAA,GAAWvB,IAAA,CAAKI,MAAL,CAAY2B,YAAZ,CAAyBR,QAAzB,CAAX;AACA,MAAIvB,IAAA,CAAKI,MAAL,CAAY4B,UAAZ,CAAuBC,eAAvB,CAAuCZ,GAAvC,CAAJ;AACE,WAAOA,GAAA,CAAImD,QAAJ,CACyClD,IADzC,EACgDC,QADhD,EAC0DW,OAD1D,EAEHT,WAFG,CAAP;AADF;AAMA,MAAI,CAACJ,GAAL;AAGE,WAAO,KAAP;AAHF;AAMA,MAAIuB,cAAc5C,IAAA,CAAKI,MAAL,CAAYyC,eAAZ,CACexB,GADf,CAAlB;AAEA,MAAIuB,WAAJ,CAAiB;AACf,QAAIG,cAAcH,WAAA,CAAY8B,WAAZ,CAC8BpD,IAD9B,EACqCC,QADrC,EAC+CW,OAD/C,EAEdT,WAFc,CAAlB;AAGA,QAAIsB,WAAJ;AACE,aAAO/C,IAAA,CAAKI,MAAL,CAAYuE,aAAZ,CAA0B5B,WAA1B,CAAP;AADF;AAJe;AASjB,SAAO,KAAP;AAlC6E,CAA/E;AA8CA/C,IAAA,CAAKI,MAAL,CAAYuE,aAAZ,GAA4BC,QAAQ,CAACC,GAAD,CAAM;AAGxC,MAAI,MAAOA,IAAX,KAAmB,QAAnB;AACE,WAAO,KAAP;AADF;AAIA,MAAItD,WAAWsD,GAAf;AACA,MAAI,CAACtD,QAAL,IAAiBA,QAAjB,CAA0BuD,OAA1B;AACE,WAAO,KAAP;AADF;AAIA,MAAIzD,MAAME,QAANF,CAAeA,GAAnB;AACA,MAAIrB,IAAA,CAAKI,MAAL,CAAY4B,UAAZ,CAAuBC,eAAvB,CAAuCZ,GAAvC,CAAJ;AACE,WAA+CA,GAAD,CAAMsD,aAAN,CAAoBpD,QAApB,CAA9C;AADF;AAIA,MAAID,OAAOC,QAAPD,CAAgBA,IAApB;AACA,MAAI2B,QAAQ1B,QAAR0B,CAAiBA,KAArB;AACA,MAAI5B,GAAJ,CAAQ0D,mBAAR;AACE1D,OAAA,CAAI0D,mBAAJ,CAAwBzD,IAAxB,EAA8B2B,KAA9B,EAAqC1B,QAArC,CAA8CW,OAA9C,CAAA;AADF;AAEO,QAAIb,GAAJ,CAAQ2D,WAAR;AACL3D,SAAA,CAAI2D,WAAJ,CAAgBhF,IAAA,CAAKI,MAAL,CAAYoD,YAAZ,CAAyBlC,IAAzB,CAAhB,EAAgD2B,KAAhD,CAAA;AADK;AAEA,UAAI5B,GAAJ,CAAQoC,WAAR,IAAuBpC,GAAvB,CAA2BqC,cAA3B;AACLrC,WAAA,CAAIqC,cAAJ,CAAmBT,KAAnB,CAAA;AADK;AAFA;AAFP;AAOAjD,MAAA,CAAKI,MAAL,CAAYc,sBAAZ,EAAA;AAEA,MAAI0B,cAAc5C,IAAA,CAAKI,MAAL,CAAYyC,eAAZ,CACexB,GADf,CAAlB;AAIA,MAAIuB,WAAJ,CAAiB;AACfA,eAAA,CAAYqC,WAAZ,CAAwB1D,QAAxB,CAAA;AACA,QAAIqB,WAAA,CAAYsC,YAAZ,EAAJ,IAAkC,CAAlC,CAAqC;AAGnCtC,iBAAA,CAAYvB,GAAZ,GAAkB,IAAlB;AAGAA,SAAA,CAAIrB,IAAJ,CAASI,MAAT,CAAgBG,kBAAhB,CAAA,GAAsC,IAAtC;AANmC;AAFtB,GAAjB;AAWwCgB,YAAD,CAAW4D,aAAX,EAAA;AAXvC;AAcA,SAAO,IAAP;AA9CwC,CAA1C;AA+DAnF,IAAA,CAAKI,MAAL,CAAYgF,mBAAZ,GAAkCC,QAAQ,CACtChE,GADsC,EACjCiD,OADiC,EACxB/C,QADwB,EACdgD,QADc,EACJ9C,WADI,CACS;AACjD6C,SAAA,CAAQE,QAAR,CAAiBnD,GAAjB,EAAsBE,QAAtB,EAAgCgD,QAAhC,EAA0C9C,WAA1C,CAAA;AADiD,CADnD;AAgBAzB,IAAA,CAAKI,MAAL,CAAYkF,SAAZ,GAAwBC,QAAQ,CAACC,GAAD,EAAMC,QAAN,CAAgB;AAI9C,MAAI,CAACD,GAAL;AACE,WAAO,CAAP;AADF;AAIA,MAAIxF,IAAA,CAAKI,MAAL,CAAY4B,UAAZ,CAAuBC,eAAvB,CAAuCuD,GAAvC,CAAJ;AACE,WAAyBA,GAAD,CAAME,kBAAN,CAAyBD,QAAzB,CAAxB;AADF;AAIA,MAAI7C,cAAc5C,IAAA,CAAKI,MAAL,CAAYyC,eAAZ,CACe2C,GADf,CAAlB;AAEA,MAAI,CAAC5C,WAAL;AACE,WAAO,CAAP;AADF;AAIA,MAAI+C,QAAQ,CAAZ;AACA,MAAIC,UAAUH,QAAVG,IAAsBH,QAAA,CAASnC,QAAT,EAA1B;AACA,OAAK,IAAIhC,IAAT,GAAiBsB,YAAjB,CAA6BiD,SAA7B;AACE,QAAI,CAACD,OAAL,IAAgBtE,IAAhB,IAAwBsE,OAAxB,CAAiC;AAG/B,UAAIC,YAAYjD,WAAA,CAAYiD,SAAZ,CAAsBvE,IAAtB,CAAA,CAA4BwE,MAA5B,EAAhB;AACA,WAAK,IAAIjE,IAAI,CAAb,EAAgBA,CAAhB,GAAoBgE,SAApB,CAA8B/D,MAA9B,EAAsC,EAAED,CAAxC;AACE,YAAI7B,IAAA,CAAKI,MAAL,CAAYuE,aAAZ,CAA0BkB,SAAA,CAAUhE,CAAV,CAA1B,CAAJ;AACE,YAAE8D,KAAF;AADF;AADF;AAJ+B;AADnC;AAYA,SAAOA,KAAP;AAhC8C,CAAhD;AA4CA3F,IAAA,CAAKI,MAAL,CAAY2F,YAAZ,GAA2BC,QAAQ,CAACR,GAAD,EAAMlE,IAAN,EAAYY,OAAZ,CAAqB;AACtD,MAAIlC,IAAA,CAAKI,MAAL,CAAY4B,UAAZ,CAAuBC,eAAvB,CAAuCuD,GAAvC,CAAJ;AACE,WAA+CA,GAAD,CAAMO,YAAN,CAC1CzE,IAD0C,EACpCY,OADoC,CAA9C;AADF,QAGO;AACL,QAAI,CAACsD,GAAL;AAGE,aAAO,EAAP;AAHF;AAMA,QAAI5C,cAAc5C,IAAA,CAAKI,MAAL,CAAYyC,eAAZ,CACe2C,GADf,CAAlB;AAEA,WAAO5C,WAAA,GAAcA,WAAA,CAAYmD,YAAZ,CAAyBzE,IAAzB,EAA+BY,OAA/B,CAAd,GAAwD,EAA/D;AATK;AAJ+C,CAAxD;AAkCAlC,IAAA,CAAKI,MAAL,CAAYsE,WAAZ,GAA0BuB,QAAQ,CAAC5E,GAAD,EAAMC,IAAN,EAAYC,QAAZ,EAAsBgD,QAAtB,EAAgC9C,WAAhC,CAA6C;AAE7EH,MAAA,GAA8BA,IAA9B;AACAC,UAAA,GAAWvB,IAAA,CAAKI,MAAL,CAAY2B,YAAZ,CAAyBR,QAAzB,CAAX;AACA,MAAIW,UAAU,CAAC,CAACqC,QAAhB;AACA,MAAIvE,IAAA,CAAKI,MAAL,CAAY4B,UAAZ,CAAuBC,eAAvB,CAAuCZ,GAAvC,CAAJ;AACE,WAAOA,GAAA,CAAIqD,WAAJ,CAAgBpD,IAAhB,EAAsBC,QAAtB,EAAgCW,OAAhC,EAAyCT,WAAzC,CAAP;AADF;AAIA,MAAI,CAACJ,GAAL;AAGE,WAAO,IAAP;AAHF;AAMA,MAAIuB,cAAc5C,IAAA,CAAKI,MAAL,CAAYyC,eAAZ,CACexB,GADf,CAAlB;AAEA,MAAIuB,WAAJ;AACE,WAAOA,WAAA,CAAY8B,WAAZ,CAAwBpD,IAAxB,EAA8BC,QAA9B,EAAwCW,OAAxC,EAAiDT,WAAjD,CAAP;AADF;AAGA,SAAO,IAAP;AApB6E,CAA/E;AAqCAzB,IAAA,CAAKI,MAAL,CAAY8F,WAAZ,GAA0BC,QAAQ,CAACX,GAAD,EAAMC,QAAN,EAAgBW,WAAhB,CAA6B;AAC7D,MAAIpG,IAAA,CAAKI,MAAL,CAAY4B,UAAZ,CAAuBC,eAAvB,CAAuCuD,GAAvC,CAAJ;AACE,WAAOA,GAAA,CAAIU,WAAJ,CAAgBT,QAAhB,EAA0BW,WAA1B,CAAP;AADF;AAIA,MAAIxD,cAAc5C,IAAA,CAAKI,MAAL,CAAYyC,eAAZ,CACe2C,GADf,CAAlB;AAEA,SAAO,CAAC,CAAC5C,WAAT,IAAwBA,WAAA,CAAYsD,WAAZ,CAAwBT,QAAxB,EAAkCW,WAAlC,CAAxB;AAP6D,CAA/D;AAgBApG,IAAA,CAAKI,MAAL,CAAYiG,MAAZ,GAAqBC,QAAQ,CAACC,CAAD,CAAI;AAC/B,MAAIC,MAAM,EAAV;AACA,OAAK,IAAI3B,GAAT,GAAgB0B,EAAhB;AACE,QAAIA,CAAA,CAAE1B,GAAF,CAAJ,IAAc0B,CAAA,CAAE1B,GAAF,CAAd,CAAqB4B,EAArB;AACED,SAAA,CAAIE,IAAJ,CAAS7B,GAAT,GAAe,QAAf,GAAuB0B,CAAA,CAAE1B,GAAF,CAAvB,GAAgC,IAAhC,GAAuC0B,CAAA,CAAE1B,GAAF,CAAvC,CAA8C4B,EAA9C,GAAmD,GAAnD,CAAA;AADF;AAGED,SAAA,CAAIE,IAAJ,CAAS7B,GAAT,GAAe,QAAf,GAAuB0B,CAAA,CAAE1B,GAAF,CAAvB,CAAA;AAHF;AADF;AAOA,SAAO2B,GAAA,CAAIG,IAAJ,CAAS,IAAT,CAAP;AAT+B,CAAjC;AAqBA3G,IAAA,CAAKI,MAAL,CAAYoD,YAAZ,GAA2BoD,QAAQ,CAACtF,IAAD,CAAO;AACxC,MAAIA,IAAJ,IAAYtB,IAAZ,CAAiBI,MAAjB,CAAwBO,YAAxB;AACE,WAAOX,IAAA,CAAKI,MAAL,CAAYO,YAAZ,CAAyBW,IAAzB,CAAP;AADF;AAGA,SAAOtB,IAAA,CAAKI,MAAL,CAAYO,YAAZ,CAAyBW,IAAzB,CAAP,GAAwCtB,IAAxC,CAA6CI,MAA7C,CAAoDM,SAApD,GAAgEY,IAAhE;AAJwC,CAA1C;AAiBAtB,IAAA,CAAKI,MAAL,CAAYyG,aAAZ,GAA4BC,QAAQ,CAACtB,GAAD,EAAMlE,IAAN,EAAYY,OAAZ,EAAqB8B,WAArB,CAAkC;AACpE,MAAIhE,IAAA,CAAKI,MAAL,CAAY4B,UAAZ,CAAuBC,eAAvB,CAAuCuD,GAAvC,CAAJ;AACE,WAA+CA,GAAD,CAAMqB,aAAN,CAC1CvF,IAD0C,EACpCY,OADoC,EAC3B8B,WAD2B,CAA9C;AADF;AAKA,SAAOhE,IAAA,CAAKI,MAAL,CAAY2G,cAAZ,CAA2BvB,GAA3B,EAAgClE,IAAhC,EAAsCY,OAAtC,EAA+C8B,WAA/C,CAAP;AANoE,CAAtE;AAmBAhE,IAAA,CAAKI,MAAL,CAAY2G,cAAZ,GAA6BC,QAAQ,CAACxB,GAAD,EAAMlE,IAAN,EAAYY,OAAZ,EAAqB8B,WAArB,CAAkC;AAErE,MAAIiD,SAAS,IAAb;AAEA,MAAIrE,cAAc5C,IAAA,CAAKI,MAAL,CAAYyC,eAAZ,CACc2C,GADd,CAAlB;AAEA,MAAI5C,WAAJ,CAAiB;AAKf,QAAIsE,gBAAgBtE,WAAA,CAAYiD,SAAZ,CAAsBvE,IAAA,CAAKgC,QAAL,EAAtB,CAApB;AACA,QAAI4D,aAAJ,CAAmB;AACjBA,mBAAA,GAAgBA,aAAA,CAAcpB,MAAd,EAAhB;AACA,WAAK,IAAIjE,IAAI,CAAb,EAAgBA,CAAhB,GAAoBqF,aAApB,CAAkCpF,MAAlC,EAA0CD,CAAA,EAA1C,CAA+C;AAC7C,YAAIN,WAAW2F,aAAA,CAAcrF,CAAd,CAAf;AAEA,YAAIN,QAAJ,IAAgBA,QAAhB,CAAyBW,OAAzB,IAAoCA,OAApC,IAA+C,CAACX,QAAD,CAAUuD,OAAzD,CAAkE;AAChE,cAAIqC,SAASnH,IAAA,CAAKI,MAAL,CAAYgH,YAAZ,CAAyB7F,QAAzB,EAAmCyC,WAAnC,CAAb;AACAiD,gBAAA,GAASA,MAAT,IAAoBE,MAApB,KAA+B,KAA/B;AAFgE;AAHrB;AAF9B;AANJ;AAkBjB,SAAOF,MAAP;AAxBqE,CAAvE;AAmCAjH,IAAA,CAAKI,MAAL,CAAYgH,YAAZ,GAA2BC,QAAQ,CAAC9F,QAAD,EAAWyC,WAAX,CAAwB;AACzD,MAAIsD,aAAa/F,QAAb+F,CAAsB/F,QAA1B;AACA,MAAIgG,kBAAkBhG,QAAlBgG,CAA2BC,OAA3BD,IAAsChG,QAAtCgG,CAA+ClG,GAAnD;AAEA,MAAIE,QAAJ,CAAae,QAAb;AACEtC,QAAA,CAAKI,MAAL,CAAYuE,aAAZ,CAA0BpD,QAA1B,CAAA;AADF;AAGA,SAAO+F,UAAA,CAAWrD,IAAX,CAAgBsD,eAAhB,EAAiCvD,WAAjC,CAAP;AAPyD,CAA3D;AAmBAhE,IAAA,CAAKI,MAAL,CAAYqH,qBAAZ,GAAoCC,QAAQ,EAAG;AAC7C,SAAO1H,IAAP,CAAYI,MAAZ,CAAmBc,sBAAnB;AAD6C,CAA/C;AAqBAlB,IAAA,CAAKI,MAAL,CAAYuH,aAAZ,GAA4BC,QAAQ,CAACvG,GAAD,EAAMkF,CAAN,CAAS;AAC3CvG,MAAA,CAAK0C,OAAL,CAAaiB,MAAb,CACI3D,IAAA,CAAKI,MAAL,CAAY4B,UAAZ,CAAuBC,eAAvB,CAAuCZ,GAAvC,CADJ,EAEI,6CAFJ,GAGQ,sCAHR,CAAA;AAIA,SAAOA,GAAA,CAAIsG,aAAJ,CAAkBpB,CAAlB,CAAP;AAL2C,CAA7C;AAgBAvG,IAAA,CAAKI,MAAL,CAAYyH,6BAAZ,GAA4CC,QAAQ,CAACC,YAAD,CAAe;AACjE/H,MAAA,CAAKI,MAAL,CAAY0D,mBAAZ,GACIiE,YAAA,CAAaC,iBAAb,CAA+BhI,IAA/B,CAAoCI,MAApC,CAA2C0D,mBAA3C,CADJ;AADiE,CAAnE;AAiBA9D,IAAA,CAAKI,MAAL,CAAY0D,mBAAZ,GAAkCmE,QAAQ,CAAC1G,QAAD,EAAW2G,OAAX,CAAoB;AAC5D,MAAI3G,QAAJ,CAAauD,OAAb;AACE,WAAO,IAAP;AADF;AAMA,MAAI,CAAC9E,IAAD,CAAMI,MAAN,CAAaoC,cAAb,CAA4BC,qBAAhC,CAAuD;AACrD,QAAI0F,UAAUD,OAAVC,IACsBnI,IAAA,CAAKoI,eAAL,CAAqB,cAArB,CAD1B;AAEA,QAAIC,MAAM,IAAIrI,IAAJ,CAASI,MAAT,CAAgBkI,YAAhB,CAA6BH,OAA7B,EAAsC,IAAtC,CAAV;AAEA,QAAIlB,SAAS,IAAb;AAEA,QAAIjH,IAAJ,CAASI,MAAT,CAAgBY,uBAAhB,IACIhB,IADJ,CACSI,MADT,CACgBQ,qBADhB,CACsCG,EADtC;AAIE,UAAI,CAACf,IAAA,CAAKI,MAAL,CAAYmI,gBAAZ,CAA6BJ,OAA7B,CAAL,CAA4C;AAC1CnI,YAAA,CAAKI,MAAL,CAAYoI,YAAZ,CAAyBL,OAAzB,CAAA;AAEA,YAAIM,YAAY,EAAhB;AACA,aAAK,IAAIC,SAASL,GAATK,CAAaC,aAAtB,EAAqCD,MAArC,EACKA,MADL,GACcA,MADd,CACqBE,UADrB;AAEEH,mBAAA,CAAU/B,IAAV,CAAegC,MAAf,CAAA;AAFF;AAMA,YAAIpH,OAAOC,QAAPD,CAAgBA,IAApB;AACA,aAAK,IAAIO,IAAI4G,SAAJ5G,CAAcC,MAAdD,GAAuB,CAAhC,EAAmC,CAACwG,GAAD,CAAKQ,mBAAxC,IAA+DhH,CAA/D,IAAoE,CAApE,EACKA,CAAA,EADL,CACU;AACRwG,aAAA,CAAIM,aAAJ,GAAoBF,SAAA,CAAU5G,CAAV,CAApB;AACA,cAAIsF,SACAnH,IAAA,CAAKI,MAAL,CAAY2G,cAAZ,CAA2B0B,SAAA,CAAU5G,CAAV,CAA3B,EAAyCP,IAAzC,EAA+C,IAA/C,EAAqD+G,GAArD,CADJ;AAEApB,gBAAA,GAASA,MAAT,IAAmBE,MAAnB;AAJQ;AAgBV,aAAK,IAAItF,IAAI,CAAb,EAAgB,CAACwG,GAAD,CAAKQ,mBAArB,IAA4ChH,CAA5C,GAAgD4G,SAAhD,CAA0D3G,MAA1D,EAAkED,CAAA,EAAlE,CAAuE;AACrEwG,aAAA,CAAIM,aAAJ,GAAoBF,SAAA,CAAU5G,CAAV,CAApB;AACA,cAAIsF,SACAnH,IAAA,CAAKI,MAAL,CAAY2G,cAAZ,CAA2B0B,SAAA,CAAU5G,CAAV,CAA3B,EAAyCP,IAAzC,EAA+C,KAA/C,EAAsD+G,GAAtD,CADJ;AAEApB,gBAAA,GAASA,MAAT,IAAmBE,MAAnB;AAJqE;AA5B7B;AAJ9C;AAwCEF,YAAA,GAASjH,IAAA,CAAKI,MAAL,CAAYgH,YAAZ,CAAyB7F,QAAzB,EAAmC8G,GAAnC,CAAT;AAxCF;AA0CA,WAAOpB,MAAP;AAjDqD;AAqDvD,SAAOjH,IAAA,CAAKI,MAAL,CAAYgH,YAAZ,CACH7F,QADG,EACO,IAAIvB,IAAJ,CAASI,MAAT,CAAgBkI,YAAhB,CAA6BJ,OAA7B,EAAsC,IAAtC,CADP,CAAP;AA5D4D,CAA9D;AAuEAlI,IAAA,CAAKI,MAAL,CAAYoI,YAAZ,GAA2BM,QAAQ,CAACvC,CAAD,CAAI;AASrC,MAAIwC,iBAAiB,KAArB;AAEA,MAAIxC,CAAJ,CAAMyC,OAAN,IAAiB,CAAjB;AAME,OAAI;AACFzC,OAAA,CAAEyC,OAAF,GAAY,EAAZ;AACA;AAFE,KAGF,QAAOC,EAAP,CAAW;AACXF,oBAAA,GAAiB,IAAjB;AADW;AATf;AAcA,MAAIA,cAAJ,IACsCxC,CAAD,CAAG2C,WADxC,IACwD7F,SADxD;AAEEkD,KAAA,CAAE2C,WAAF,GAAgB,IAAhB;AAFF;AAzBqC,CAAvC;AAuCAlJ,IAAA,CAAKI,MAAL,CAAYmI,gBAAZ,GAA+BY,QAAQ,CAAC5C,CAAD,CAAI;AACzC,SAAOA,CAAP,CAASyC,OAAT,GAAmB,CAAnB,IAAwBzC,CAAxB,CAA0B2C,WAA1B,IAAyC7F,SAAzC;AADyC,CAA3C;AASArD,IAAA,CAAKI,MAAL,CAAYgJ,gBAAZ,GAA+B,CAA/B;AAUApJ,IAAA,CAAKI,MAAL,CAAYiJ,WAAZ,GAA0BC,QAAQ,CAACC,UAAD,CAAa;AAC7C,SAAOA,UAAP,GAAoB,GAApB,GAA0BvJ,IAAA,CAAKI,MAAL,CAAYgJ,gBAAZ,EAA1B;AAD6C,CAA/C;AAWApJ,IAAA,CAAKI,MAAL,CAAYyC,eAAZ,GAA8B2G,QAAQ,CAACnI,GAAD,CAAM;AAC1C,MAAIuB,cAAcvB,GAAA,CAAIrB,IAAJ,CAASI,MAAT,CAAgBG,kBAAhB,CAAlB;AAGA,SAAOqC,WAAA,YAAuB5C,IAAvB,CAA4BI,MAA5B,CAAmC0C,WAAnC,GAAiDF,WAAjD,GAA+D,IAAtE;AAJ0C,CAA5C;AAaA5C,IAAA,CAAKI,MAAL,CAAYqJ,sBAAZ,GACI,sBADJ,IAC+BjJ,IAAA,CAAKC,MAAL,EAD/B,GAC+C,GAD/C,KACwD,CADxD;AAYAT,IAAA,CAAKI,MAAL,CAAY2B,YAAZ,GAA2B2H,QAAQ,CAACnI,QAAD,CAAW;AAC5CvB,MAAA,CAAK0C,OAAL,CAAaiB,MAAb,CAAoBpC,QAApB,EAA8B,2BAA9B,CAAA;AAEA,MAAIvB,IAAA,CAAK2J,UAAL,CAAgBpI,QAAhB,CAAJ;AACE,WAAOA,QAAP;AADF;AAIAvB,MAAA,CAAK0C,OAAL,CAAaiB,MAAb,CACIpC,QADJ,CACaqI,WADb,EAC0B,kDAD1B,CAAA;AAEA,MAAI,CAACrI,QAAA,CAASvB,IAAT,CAAcI,MAAd,CAAqBqJ,sBAArB,CAAL;AACElI,YAAA,CAASvB,IAAT,CAAcI,MAAd,CAAqBqJ,sBAArB,CAAA,GAA+C,QAAQ,CAAClD,CAAD,CAAI;AACzD,aAAyBhF,QAAD,CAAWqI,WAAX,CAAuBrD,CAAvB,CAAxB;AADyD,KAA3D;AADF;AAKA,SAAOhF,QAAA,CAASvB,IAAT,CAAcI,MAAd,CAAqBqJ,sBAArB,CAAP;AAd4C,CAA9C;AAoBAzJ,IAAA,CAAK6J,KAAL,CAAWC,kBAAX,CAA8BC,QAA9B,CAKI,QAAQ,CAACC,WAAD,CAAc;AACpBhK,MAAA,CAAKI,MAAL,CAAY0D,mBAAZ,GACIkG,WAAA,CAAYhK,IAAZ,CAAiBI,MAAjB,CAAwB0D,mBAAxB,CADJ;AADoB,CAL1B,CAAA;;",
"sources":["goog/events/events.js"],
"sourcesContent":["// Copyright 2005 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview An event manager for both native browser event\n * targets and custom JavaScript event targets\n * (`goog.events.Listenable`). This provides an abstraction\n * over browsers' event systems.\n *\n * It also provides a simulation of W3C event model's capture phase in\n * Internet Explorer (IE 8 and below). Caveat: the simulation does not\n * interact well with listeners registered directly on the elements\n * (bypassing goog.events) or even with listeners registered via\n * goog.events in a separate JS binary. In these cases, we provide\n * no ordering guarantees.\n *\n * The listeners will receive a \"patched\" event object. Such event object\n * contains normalized values for certain event properties that differs in\n * different browsers.\n *\n * Example usage:\n * <pre>\n * goog.events.listen(myNode, 'click', function(e) { alert('woo') });\n * goog.events.listen(myNode, 'mouseover', mouseHandler, true);\n * goog.events.unlisten(myNode, 'mouseover', mouseHandler, true);\n * goog.events.removeAll(myNode);\n * </pre>\n *\n *                                            in IE and event object patching]\n * @author arv@google.com (Erik Arvidsson)\n *\n * @see ../demos/events.html\n * @see ../demos/event-propagation.html\n * @see ../demos/stopevent.html\n */\n\n// IMPLEMENTATION NOTES:\n// goog.events stores an auxiliary data structure on each EventTarget\n// source being listened on. This allows us to take advantage of GC,\n// having the data structure GC'd when the EventTarget is GC'd. This\n// GC behavior is equivalent to using W3C DOM Events directly.\n\ngoog.provide('goog.events');\ngoog.provide('goog.events.CaptureSimulationMode');\ngoog.provide('goog.events.Key');\ngoog.provide('goog.events.ListenableType');\n\ngoog.forwardDeclare('goog.debug.ErrorHandler');\ngoog.forwardDeclare('goog.events.EventWrapper');\ngoog.require('goog.asserts');\ngoog.require('goog.debug.entryPointRegistry');\ngoog.require('goog.events.BrowserEvent');\ngoog.require('goog.events.BrowserFeature');\ngoog.require('goog.events.Listenable');\ngoog.require('goog.events.ListenerMap');\n\n\n/**\n * @typedef {number|goog.events.ListenableKey}\n */\ngoog.events.Key;\n\n\n/**\n * @typedef {EventTarget|goog.events.Listenable}\n */\ngoog.events.ListenableType;\n\n\n/**\n * Property name on a native event target for the listener map\n * associated with the event target.\n * @private @const {string}\n */\ngoog.events.LISTENER_MAP_PROP_ = 'closure_lm_' + ((Math.random() * 1e6) | 0);\n\n\n/**\n * String used to prepend to IE event types.\n * @const\n * @private\n */\ngoog.events.onString_ = 'on';\n\n\n/**\n * Map of computed \"on<eventname>\" strings for IE event types. Caching\n * this removes an extra object allocation in goog.events.listen which\n * improves IE6 performance.\n * @const\n * @dict\n * @private\n */\ngoog.events.onStringMap_ = {};\n\n\n/**\n * @enum {number} Different capture simulation mode for IE8-.\n */\ngoog.events.CaptureSimulationMode = {\n  /**\n   * Does not perform capture simulation. Will asserts in IE8- when you\n   * add capture listeners.\n   */\n  OFF_AND_FAIL: 0,\n\n  /**\n   * Does not perform capture simulation, silently ignore capture\n   * listeners.\n   */\n  OFF_AND_SILENT: 1,\n\n  /**\n   * Performs capture simulation.\n   */\n  ON: 2\n};\n\n\n/**\n * @define {number} The capture simulation mode for IE8-. By default,\n *     this is ON.\n */\ngoog.events.CAPTURE_SIMULATION_MODE =\n    goog.define('goog.events.CAPTURE_SIMULATION_MODE', 2);\n\n\n/**\n * Estimated count of total native listeners.\n * @private {number}\n */\ngoog.events.listenerCountEstimate_ = 0;\n\n\n/**\n * Adds an event listener for a specific event on a native event\n * target (such as a DOM element) or an object that has implemented\n * {@link goog.events.Listenable}. A listener can only be added once\n * to an object and if it is added again the key for the listener is\n * returned. Note that if the existing listener is a one-off listener\n * (registered via listenOnce), it will no longer be a one-off\n * listener after a call to listen().\n *\n * @param {EventTarget|goog.events.Listenable} src The node to listen\n *     to events on.\n * @param {string|Array<string>|\n *     !goog.events.EventId<EVENTOBJ>|!Array<!goog.events.EventId<EVENTOBJ>>}\n *     type Event type or array of event types.\n * @param {function(this:T, EVENTOBJ):?|{handleEvent:function(?):?}|null}\n *     listener Callback method, or an object with a handleEvent function.\n *     WARNING: passing an Object is now softly deprecated.\n * @param {(boolean|!AddEventListenerOptions)=} opt_options\n * @param {T=} opt_handler Element in whose scope to call the listener.\n * @return {goog.events.Key} Unique key for the listener.\n * @template T,EVENTOBJ\n */\ngoog.events.listen = function(src, type, listener, opt_options, opt_handler) {\n  if (opt_options && opt_options.once) {\n    return goog.events.listenOnce(\n        src, type, listener, opt_options, opt_handler);\n  }\n  if (goog.isArray(type)) {\n    for (var i = 0; i < type.length; i++) {\n      goog.events.listen(src, type[i], listener, opt_options, opt_handler);\n    }\n    return null;\n  }\n\n  listener = goog.events.wrapListener(listener);\n  if (goog.events.Listenable.isImplementedBy(src)) {\n    var capture =\n        goog.isObject(opt_options) ? !!opt_options.capture : !!opt_options;\n    return src.listen(\n        /** @type {string|!goog.events.EventId} */ (type), listener, capture,\n        opt_handler);\n  } else {\n    return goog.events.listen_(\n        /** @type {!EventTarget} */ (src), type, listener,\n        /* callOnce */ false, opt_options, opt_handler);\n  }\n};\n\n\n/**\n * Adds an event listener for a specific event on a native event\n * target. A listener can only be added once to an object and if it\n * is added again the key for the listener is returned.\n *\n * Note that a one-off listener will not change an existing listener,\n * if any. On the other hand a normal listener will change existing\n * one-off listener to become a normal listener.\n *\n * @param {EventTarget} src The node to listen to events on.\n * @param {string|?goog.events.EventId<EVENTOBJ>} type Event type.\n * @param {!Function} listener Callback function.\n * @param {boolean} callOnce Whether the listener is a one-off\n *     listener or otherwise.\n * @param {(boolean|!AddEventListenerOptions)=} opt_options\n * @param {Object=} opt_handler Element in whose scope to call the listener.\n * @return {goog.events.ListenableKey} Unique key for the listener.\n * @template EVENTOBJ\n * @private\n */\ngoog.events.listen_ = function(\n    src, type, listener, callOnce, opt_options, opt_handler) {\n  if (!type) {\n    throw new Error('Invalid event type');\n  }\n\n  var capture =\n      goog.isObject(opt_options) ? !!opt_options.capture : !!opt_options;\n  if (capture && !goog.events.BrowserFeature.HAS_W3C_EVENT_SUPPORT) {\n    if (goog.events.CAPTURE_SIMULATION_MODE ==\n        goog.events.CaptureSimulationMode.OFF_AND_FAIL) {\n      goog.asserts.fail('Can not register capture listener in IE8-.');\n      return null;\n    } else if (\n        goog.events.CAPTURE_SIMULATION_MODE ==\n        goog.events.CaptureSimulationMode.OFF_AND_SILENT) {\n      return null;\n    }\n  }\n\n  var listenerMap = goog.events.getListenerMap_(src);\n  if (!listenerMap) {\n    src[goog.events.LISTENER_MAP_PROP_] = listenerMap =\n        new goog.events.ListenerMap(src);\n  }\n\n  var listenerObj = /** @type {goog.events.Listener} */ (\n      listenerMap.add(type, listener, callOnce, capture, opt_handler));\n\n  // If the listenerObj already has a proxy, it has been set up\n  // previously. We simply return.\n  if (listenerObj.proxy) {\n    return listenerObj;\n  }\n\n  var proxy = goog.events.getProxy();\n  listenerObj.proxy = proxy;\n\n  proxy.src = src;\n  proxy.listener = listenerObj;\n\n  // Attach the proxy through the browser's API\n  if (src.addEventListener) {\n    // Don't pass an object as `capture` if the browser doesn't support that.\n    if (!goog.events.BrowserFeature.PASSIVE_EVENTS) {\n      opt_options = capture;\n    }\n    // Don't break tests that expect a boolean.\n    if (opt_options === undefined) opt_options = false;\n    src.addEventListener(type.toString(), proxy, opt_options);\n  } else if (src.attachEvent) {\n    // The else if above used to be an unconditional else. It would call\n    // exception on IE11, spoiling the day of some callers. The previous\n    // incarnation of this code, from 2007, indicates that it replaced an\n    // earlier still version that caused excess allocations on IE6.\n    src.attachEvent(goog.events.getOnString_(type.toString()), proxy);\n  } else if (src.addListener && src.removeListener) {\n    // In IE, MediaQueryList uses addListener() insteadd of addEventListener. In\n    // Safari, there is no global for the MediaQueryList constructor, so we just\n    // check whether the object \"looks like\" MediaQueryList.\n    goog.asserts.assert(\n        type === 'change', 'MediaQueryList only has a change event');\n    src.addListener(proxy);\n  } else {\n    throw new Error('addEventListener and attachEvent are unavailable.');\n  }\n\n  goog.events.listenerCountEstimate_++;\n  return listenerObj;\n};\n\n\n/**\n * Helper function for returning a proxy function.\n * @return {!Function} A new or reused function object.\n */\ngoog.events.getProxy = function() {\n  var proxyCallbackFunction = goog.events.handleBrowserEvent_;\n  // Use a local var f to prevent one allocation.\n  var f =\n      goog.events.BrowserFeature.HAS_W3C_EVENT_SUPPORT ? function(eventObject) {\n        return proxyCallbackFunction.call(f.src, f.listener, eventObject);\n      } : function(eventObject) {\n        var v = proxyCallbackFunction.call(f.src, f.listener, eventObject);\n        // NOTE(chrishenry): In IE, we hack in a capture phase. However, if\n        // there is inline event handler which tries to prevent default (for\n        // example <a href=\"...\" onclick=\"return false\">...</a>) in a\n        // descendant element, the prevent default will be overridden\n        // by this listener if this listener were to return true. Hence, we\n        // return undefined.\n        if (!v) return v;\n      };\n  return f;\n};\n\n\n/**\n * Adds an event listener for a specific event on a native event\n * target (such as a DOM element) or an object that has implemented\n * {@link goog.events.Listenable}. After the event has fired the event\n * listener is removed from the target.\n *\n * If an existing listener already exists, listenOnce will do\n * nothing. In particular, if the listener was previously registered\n * via listen(), listenOnce() will not turn the listener into a\n * one-off listener. Similarly, if there is already an existing\n * one-off listener, listenOnce does not modify the listeners (it is\n * still a once listener).\n *\n * @param {EventTarget|goog.events.Listenable} src The node to listen\n *     to events on.\n * @param {string|Array<string>|\n *     !goog.events.EventId<EVENTOBJ>|!Array<!goog.events.EventId<EVENTOBJ>>}\n *     type Event type or array of event types.\n * @param {function(this:T, EVENTOBJ):?|{handleEvent:function(?):?}|null}\n *     listener Callback method.\n * @param {(boolean|!AddEventListenerOptions)=} opt_options\n * @param {T=} opt_handler Element in whose scope to call the listener.\n * @return {goog.events.Key} Unique key for the listener.\n * @template T,EVENTOBJ\n */\ngoog.events.listenOnce = function(\n    src, type, listener, opt_options, opt_handler) {\n  if (goog.isArray(type)) {\n    for (var i = 0; i < type.length; i++) {\n      goog.events.listenOnce(src, type[i], listener, opt_options, opt_handler);\n    }\n    return null;\n  }\n\n  listener = goog.events.wrapListener(listener);\n  if (goog.events.Listenable.isImplementedBy(src)) {\n    var capture =\n        goog.isObject(opt_options) ? !!opt_options.capture : !!opt_options;\n    return src.listenOnce(\n        /** @type {string|!goog.events.EventId} */ (type), listener, capture,\n        opt_handler);\n  } else {\n    return goog.events.listen_(\n        /** @type {!EventTarget} */ (src), type, listener,\n        /* callOnce */ true, opt_options, opt_handler);\n  }\n};\n\n\n/**\n * Adds an event listener with a specific event wrapper on a DOM Node or an\n * object that has implemented {@link goog.events.Listenable}. A listener can\n * only be added once to an object.\n *\n * @param {EventTarget|goog.events.Listenable} src The target to\n *     listen to events on.\n * @param {goog.events.EventWrapper} wrapper Event wrapper to use.\n * @param {function(this:T, ?):?|{handleEvent:function(?):?}|null} listener\n *     Callback method, or an object with a handleEvent function.\n * @param {boolean=} opt_capt Whether to fire in capture phase (defaults to\n *     false).\n * @param {T=} opt_handler Element in whose scope to call the listener.\n * @template T\n */\ngoog.events.listenWithWrapper = function(\n    src, wrapper, listener, opt_capt, opt_handler) {\n  wrapper.listen(src, listener, opt_capt, opt_handler);\n};\n\n\n/**\n * Removes an event listener which was added with listen().\n *\n * @param {EventTarget|goog.events.Listenable} src The target to stop\n *     listening to events on.\n * @param {string|Array<string>|\n *     !goog.events.EventId<EVENTOBJ>|!Array<!goog.events.EventId<EVENTOBJ>>}\n *     type Event type or array of event types to unlisten to.\n * @param {function(?):?|{handleEvent:function(?):?}|null} listener The\n *     listener function to remove.\n * @param {(boolean|!EventListenerOptions)=} opt_options\n *     whether the listener is fired during the capture or bubble phase of the\n *     event.\n * @param {Object=} opt_handler Element in whose scope to call the listener.\n * @return {?boolean} indicating whether the listener was there to remove.\n * @template EVENTOBJ\n */\ngoog.events.unlisten = function(src, type, listener, opt_options, opt_handler) {\n  if (goog.isArray(type)) {\n    for (var i = 0; i < type.length; i++) {\n      goog.events.unlisten(src, type[i], listener, opt_options, opt_handler);\n    }\n    return null;\n  }\n  var capture =\n      goog.isObject(opt_options) ? !!opt_options.capture : !!opt_options;\n\n  listener = goog.events.wrapListener(listener);\n  if (goog.events.Listenable.isImplementedBy(src)) {\n    return src.unlisten(\n        /** @type {string|!goog.events.EventId} */ (type), listener, capture,\n        opt_handler);\n  }\n\n  if (!src) {\n    // TODO(chrishenry): We should tighten the API to only accept\n    // non-null objects, or add an assertion here.\n    return false;\n  }\n\n  var listenerMap = goog.events.getListenerMap_(\n      /** @type {!EventTarget} */ (src));\n  if (listenerMap) {\n    var listenerObj = listenerMap.getListener(\n        /** @type {string|!goog.events.EventId} */ (type), listener, capture,\n        opt_handler);\n    if (listenerObj) {\n      return goog.events.unlistenByKey(listenerObj);\n    }\n  }\n\n  return false;\n};\n\n\n/**\n * Removes an event listener which was added with listen() by the key\n * returned by listen().\n *\n * @param {goog.events.Key} key The key returned by listen() for this\n *     event listener.\n * @return {boolean} indicating whether the listener was there to remove.\n */\ngoog.events.unlistenByKey = function(key) {\n  // TODO(chrishenry): Remove this check when tests that rely on this\n  // are fixed.\n  if (typeof key === 'number') {\n    return false;\n  }\n\n  var listener = key;\n  if (!listener || listener.removed) {\n    return false;\n  }\n\n  var src = listener.src;\n  if (goog.events.Listenable.isImplementedBy(src)) {\n    return /** @type {!goog.events.Listenable} */ (src).unlistenByKey(listener);\n  }\n\n  var type = listener.type;\n  var proxy = listener.proxy;\n  if (src.removeEventListener) {\n    src.removeEventListener(type, proxy, listener.capture);\n  } else if (src.detachEvent) {\n    src.detachEvent(goog.events.getOnString_(type), proxy);\n  } else if (src.addListener && src.removeListener) {\n    src.removeListener(proxy);\n  }\n  goog.events.listenerCountEstimate_--;\n\n  var listenerMap = goog.events.getListenerMap_(\n      /** @type {!EventTarget} */ (src));\n  // TODO(chrishenry): Try to remove this conditional and execute the\n  // first branch always. This should be safe.\n  if (listenerMap) {\n    listenerMap.removeByKey(listener);\n    if (listenerMap.getTypeCount() == 0) {\n      // Null the src, just because this is simple to do (and useful\n      // for IE <= 7).\n      listenerMap.src = null;\n      // We don't use delete here because IE does not allow delete\n      // on a window object.\n      src[goog.events.LISTENER_MAP_PROP_] = null;\n    }\n  } else {\n    /** @type {!goog.events.Listener} */ (listener).markAsRemoved();\n  }\n\n  return true;\n};\n\n\n/**\n * Removes an event listener which was added with listenWithWrapper().\n *\n * @param {EventTarget|goog.events.Listenable} src The target to stop\n *     listening to events on.\n * @param {goog.events.EventWrapper} wrapper Event wrapper to use.\n * @param {function(?):?|{handleEvent:function(?):?}|null} listener The\n *     listener function to remove.\n * @param {boolean=} opt_capt In DOM-compliant browsers, this determines\n *     whether the listener is fired during the capture or bubble phase of the\n *     event.\n * @param {Object=} opt_handler Element in whose scope to call the listener.\n */\ngoog.events.unlistenWithWrapper = function(\n    src, wrapper, listener, opt_capt, opt_handler) {\n  wrapper.unlisten(src, listener, opt_capt, opt_handler);\n};\n\n\n/**\n * Removes all listeners from an object. You can also optionally\n * remove listeners of a particular type.\n *\n * @param {Object|undefined} obj Object to remove listeners from. Must be an\n *     EventTarget or a goog.events.Listenable.\n * @param {string|!goog.events.EventId=} opt_type Type of event to remove.\n *     Default is all types.\n * @return {number} Number of listeners removed.\n */\ngoog.events.removeAll = function(obj, opt_type) {\n  // TODO(chrishenry): Change the type of obj to\n  // (!EventTarget|!goog.events.Listenable).\n\n  if (!obj) {\n    return 0;\n  }\n\n  if (goog.events.Listenable.isImplementedBy(obj)) {\n    return /** @type {?} */ (obj).removeAllListeners(opt_type);\n  }\n\n  var listenerMap = goog.events.getListenerMap_(\n      /** @type {!EventTarget} */ (obj));\n  if (!listenerMap) {\n    return 0;\n  }\n\n  var count = 0;\n  var typeStr = opt_type && opt_type.toString();\n  for (var type in listenerMap.listeners) {\n    if (!typeStr || type == typeStr) {\n      // Clone so that we don't need to worry about unlistenByKey\n      // changing the content of the ListenerMap.\n      var listeners = listenerMap.listeners[type].concat();\n      for (var i = 0; i < listeners.length; ++i) {\n        if (goog.events.unlistenByKey(listeners[i])) {\n          ++count;\n        }\n      }\n    }\n  }\n  return count;\n};\n\n\n/**\n * Gets the listeners for a given object, type and capture phase.\n *\n * @param {Object} obj Object to get listeners for.\n * @param {string|!goog.events.EventId} type Event type.\n * @param {boolean} capture Capture phase?.\n * @return {Array<!goog.events.Listener>} Array of listener objects.\n */\ngoog.events.getListeners = function(obj, type, capture) {\n  if (goog.events.Listenable.isImplementedBy(obj)) {\n    return /** @type {!goog.events.Listenable} */ (obj).getListeners(\n        type, capture);\n  } else {\n    if (!obj) {\n      // TODO(chrishenry): We should tighten the API to accept\n      // !EventTarget|goog.events.Listenable, and add an assertion here.\n      return [];\n    }\n\n    var listenerMap = goog.events.getListenerMap_(\n        /** @type {!EventTarget} */ (obj));\n    return listenerMap ? listenerMap.getListeners(type, capture) : [];\n  }\n};\n\n\n/**\n * Gets the goog.events.Listener for the event or null if no such listener is\n * in use.\n *\n * @param {EventTarget|goog.events.Listenable} src The target from\n *     which to get listeners.\n * @param {?string|!goog.events.EventId<EVENTOBJ>} type The type of the event.\n * @param {function(EVENTOBJ):?|{handleEvent:function(?):?}|null} listener The\n *     listener function to get.\n * @param {boolean=} opt_capt In DOM-compliant browsers, this determines\n *                            whether the listener is fired during the\n *                            capture or bubble phase of the event.\n * @param {Object=} opt_handler Element in whose scope to call the listener.\n * @return {goog.events.ListenableKey} the found listener or null if not found.\n * @template EVENTOBJ\n */\ngoog.events.getListener = function(src, type, listener, opt_capt, opt_handler) {\n  // TODO(chrishenry): Change type from ?string to string, or add assertion.\n  type = /** @type {string} */ (type);\n  listener = goog.events.wrapListener(listener);\n  var capture = !!opt_capt;\n  if (goog.events.Listenable.isImplementedBy(src)) {\n    return src.getListener(type, listener, capture, opt_handler);\n  }\n\n  if (!src) {\n    // TODO(chrishenry): We should tighten the API to only accept\n    // non-null objects, or add an assertion here.\n    return null;\n  }\n\n  var listenerMap = goog.events.getListenerMap_(\n      /** @type {!EventTarget} */ (src));\n  if (listenerMap) {\n    return listenerMap.getListener(type, listener, capture, opt_handler);\n  }\n  return null;\n};\n\n\n/**\n * Returns whether an event target has any active listeners matching the\n * specified signature. If either the type or capture parameters are\n * unspecified, the function will match on the remaining criteria.\n *\n * @param {EventTarget|goog.events.Listenable} obj Target to get\n *     listeners for.\n * @param {string|!goog.events.EventId=} opt_type Event type.\n * @param {boolean=} opt_capture Whether to check for capture or bubble-phase\n *     listeners.\n * @return {boolean} Whether an event target has one or more listeners matching\n *     the requested type and/or capture phase.\n */\ngoog.events.hasListener = function(obj, opt_type, opt_capture) {\n  if (goog.events.Listenable.isImplementedBy(obj)) {\n    return obj.hasListener(opt_type, opt_capture);\n  }\n\n  var listenerMap = goog.events.getListenerMap_(\n      /** @type {!EventTarget} */ (obj));\n  return !!listenerMap && listenerMap.hasListener(opt_type, opt_capture);\n};\n\n\n/**\n * Provides a nice string showing the normalized event objects public members\n * @param {Object} e Event Object.\n * @return {string} String of the public members of the normalized event object.\n */\ngoog.events.expose = function(e) {\n  var str = [];\n  for (var key in e) {\n    if (e[key] && e[key].id) {\n      str.push(key + ' = ' + e[key] + ' (' + e[key].id + ')');\n    } else {\n      str.push(key + ' = ' + e[key]);\n    }\n  }\n  return str.join('\\n');\n};\n\n\n/**\n * Returns a string with on prepended to the specified type. This is used for IE\n * which expects \"on\" to be prepended. This function caches the string in order\n * to avoid extra allocations in steady state.\n * @param {string} type Event type.\n * @return {string} The type string with 'on' prepended.\n * @private\n */\ngoog.events.getOnString_ = function(type) {\n  if (type in goog.events.onStringMap_) {\n    return goog.events.onStringMap_[type];\n  }\n  return goog.events.onStringMap_[type] = goog.events.onString_ + type;\n};\n\n\n/**\n * Fires an object's listeners of a particular type and phase\n *\n * @param {Object} obj Object whose listeners to call.\n * @param {string|!goog.events.EventId} type Event type.\n * @param {boolean} capture Which event phase.\n * @param {Object} eventObject Event object to be passed to listener.\n * @return {boolean} True if all listeners returned true else false.\n */\ngoog.events.fireListeners = function(obj, type, capture, eventObject) {\n  if (goog.events.Listenable.isImplementedBy(obj)) {\n    return /** @type {!goog.events.Listenable} */ (obj).fireListeners(\n        type, capture, eventObject);\n  }\n\n  return goog.events.fireListeners_(obj, type, capture, eventObject);\n};\n\n\n/**\n * Fires an object's listeners of a particular type and phase.\n * @param {Object} obj Object whose listeners to call.\n * @param {string|!goog.events.EventId} type Event type.\n * @param {boolean} capture Which event phase.\n * @param {Object} eventObject Event object to be passed to listener.\n * @return {boolean} True if all listeners returned true else false.\n * @private\n */\ngoog.events.fireListeners_ = function(obj, type, capture, eventObject) {\n  /** @type {boolean} */\n  var retval = true;\n\n  var listenerMap = goog.events.getListenerMap_(\n      /** @type {EventTarget} */ (obj));\n  if (listenerMap) {\n    // TODO(chrishenry): Original code avoids array creation when there\n    // is no listener, so we do the same. If this optimization turns\n    // out to be not required, we can replace this with\n    // listenerMap.getListeners(type, capture) instead, which is simpler.\n    var listenerArray = listenerMap.listeners[type.toString()];\n    if (listenerArray) {\n      listenerArray = listenerArray.concat();\n      for (var i = 0; i < listenerArray.length; i++) {\n        var listener = listenerArray[i];\n        // We might not have a listener if the listener was removed.\n        if (listener && listener.capture == capture && !listener.removed) {\n          var result = goog.events.fireListener(listener, eventObject);\n          retval = retval && (result !== false);\n        }\n      }\n    }\n  }\n  return retval;\n};\n\n\n/**\n * Fires a listener with a set of arguments\n *\n * @param {goog.events.Listener} listener The listener object to call.\n * @param {Object} eventObject The event object to pass to the listener.\n * @return {*} Result of listener.\n */\ngoog.events.fireListener = function(listener, eventObject) {\n  var listenerFn = listener.listener;\n  var listenerHandler = listener.handler || listener.src;\n\n  if (listener.callOnce) {\n    goog.events.unlistenByKey(listener);\n  }\n  return listenerFn.call(listenerHandler, eventObject);\n};\n\n\n/**\n * Gets the total number of listeners currently in the system.\n * @return {number} Number of listeners.\n * @deprecated This returns estimated count, now that Closure no longer\n * stores a central listener registry. We still return an estimation\n * to keep existing listener-related tests passing. In the near future,\n * this function will be removed.\n */\ngoog.events.getTotalListenerCount = function() {\n  return goog.events.listenerCountEstimate_;\n};\n\n\n/**\n * Dispatches an event (or event like object) and calls all listeners\n * listening for events of this type. The type of the event is decided by the\n * type property on the event object.\n *\n * If any of the listeners returns false OR calls preventDefault then this\n * function will return false.  If one of the capture listeners calls\n * stopPropagation, then the bubble listeners won't fire.\n *\n * @param {goog.events.Listenable} src The event target.\n * @param {goog.events.EventLike} e Event object.\n * @return {boolean} If anyone called preventDefault on the event object (or\n *     if any of the handlers returns false) this will also return false.\n *     If there are no handlers, or if all handlers return true, this returns\n *     true.\n */\ngoog.events.dispatchEvent = function(src, e) {\n  goog.asserts.assert(\n      goog.events.Listenable.isImplementedBy(src),\n      'Can not use goog.events.dispatchEvent with ' +\n          'non-goog.events.Listenable instance.');\n  return src.dispatchEvent(e);\n};\n\n\n/**\n * Installs exception protection for the browser event entry point using the\n * given error handler.\n *\n * @param {goog.debug.ErrorHandler} errorHandler Error handler with which to\n *     protect the entry point.\n */\ngoog.events.protectBrowserEventEntryPoint = function(errorHandler) {\n  goog.events.handleBrowserEvent_ =\n      errorHandler.protectEntryPoint(goog.events.handleBrowserEvent_);\n};\n\n\n/**\n * Handles an event and dispatches it to the correct listeners. This\n * function is a proxy for the real listener the user specified.\n *\n * @param {goog.events.Listener} listener The listener object.\n * @param {Event=} opt_evt Optional event object that gets passed in via the\n *     native event handlers.\n * @return {*} Result of the event handler.\n * @this {EventTarget} The object or Element that fired the event.\n * @private\n */\ngoog.events.handleBrowserEvent_ = function(listener, opt_evt) {\n  if (listener.removed) {\n    return true;\n  }\n\n  // Synthesize event propagation if the browser does not support W3C\n  // event model.\n  if (!goog.events.BrowserFeature.HAS_W3C_EVENT_SUPPORT) {\n    var ieEvent = opt_evt ||\n        /** @type {Event} */ (goog.getObjectByName('window.event'));\n    var evt = new goog.events.BrowserEvent(ieEvent, this);\n    /** @type {*} */\n    var retval = true;\n\n    if (goog.events.CAPTURE_SIMULATION_MODE ==\n        goog.events.CaptureSimulationMode.ON) {\n      // If we have not marked this event yet, we should perform capture\n      // simulation.\n      if (!goog.events.isMarkedIeEvent_(ieEvent)) {\n        goog.events.markIeEvent_(ieEvent);\n\n        var ancestors = [];\n        for (var parent = evt.currentTarget; parent;\n             parent = parent.parentNode) {\n          ancestors.push(parent);\n        }\n\n        // Fire capture listeners.\n        var type = listener.type;\n        for (var i = ancestors.length - 1; !evt.propagationStopped_ && i >= 0;\n             i--) {\n          evt.currentTarget = ancestors[i];\n          var result =\n              goog.events.fireListeners_(ancestors[i], type, true, evt);\n          retval = retval && result;\n        }\n\n        // Fire bubble listeners.\n        //\n        // We can technically rely on IE to perform bubble event\n        // propagation. However, it turns out that IE fires events in\n        // opposite order of attachEvent registration, which broke\n        // some code and tests that rely on the order. (While W3C DOM\n        // Level 2 Events TR leaves the event ordering unspecified,\n        // modern browsers and W3C DOM Level 3 Events Working Draft\n        // actually specify the order as the registration order.)\n        for (var i = 0; !evt.propagationStopped_ && i < ancestors.length; i++) {\n          evt.currentTarget = ancestors[i];\n          var result =\n              goog.events.fireListeners_(ancestors[i], type, false, evt);\n          retval = retval && result;\n        }\n      }\n    } else {\n      retval = goog.events.fireListener(listener, evt);\n    }\n    return retval;\n  }\n\n  // Otherwise, simply fire the listener.\n  return goog.events.fireListener(\n      listener, new goog.events.BrowserEvent(opt_evt, this));\n};\n\n\n/**\n * This is used to mark the IE event object so we do not do the Closure pass\n * twice for a bubbling event.\n * @param {Event} e The IE browser event.\n * @private\n */\ngoog.events.markIeEvent_ = function(e) {\n  // Only the keyCode and the returnValue can be changed. We use keyCode for\n  // non keyboard events.\n  // event.returnValue is a bit more tricky. It is undefined by default. A\n  // boolean false prevents the default action. In a window.onbeforeunload and\n  // the returnValue is non undefined it will be alerted. However, we will only\n  // modify the returnValue for keyboard events. We can get a problem if non\n  // closure events sets the keyCode or the returnValue\n\n  var useReturnValue = false;\n\n  if (e.keyCode == 0) {\n    // We cannot change the keyCode in case that srcElement is input[type=file].\n    // We could test that that is the case but that would allocate 3 objects.\n    // If we use try/catch we will only allocate extra objects in the case of a\n    // failure.\n\n    try {\n      e.keyCode = -1;\n      return;\n    } catch (ex) {\n      useReturnValue = true;\n    }\n  }\n\n  if (useReturnValue ||\n      /** @type {boolean|undefined} */ (e.returnValue) == undefined) {\n    e.returnValue = true;\n  }\n};\n\n\n/**\n * This is used to check if an IE event has already been handled by the Closure\n * system so we do not do the Closure pass twice for a bubbling event.\n * @param {Event} e  The IE browser event.\n * @return {boolean} True if the event object has been marked.\n * @private\n */\ngoog.events.isMarkedIeEvent_ = function(e) {\n  return e.keyCode < 0 || e.returnValue != undefined;\n};\n\n\n/**\n * Counter to create unique event ids.\n * @private {number}\n */\ngoog.events.uniqueIdCounter_ = 0;\n\n\n/**\n * Creates a unique event id.\n *\n * @param {string} identifier The identifier.\n * @return {string} A unique identifier.\n * @idGenerator {unique}\n */\ngoog.events.getUniqueId = function(identifier) {\n  return identifier + '_' + goog.events.uniqueIdCounter_++;\n};\n\n\n/**\n * @param {EventTarget} src The source object.\n * @return {goog.events.ListenerMap} A listener map for the given\n *     source object, or null if none exists.\n * @private\n */\ngoog.events.getListenerMap_ = function(src) {\n  var listenerMap = src[goog.events.LISTENER_MAP_PROP_];\n  // IE serializes the property as well (e.g. when serializing outer\n  // HTML). So we must check that the value is of the correct type.\n  return listenerMap instanceof goog.events.ListenerMap ? listenerMap : null;\n};\n\n\n/**\n * Expando property for listener function wrapper for Object with\n * handleEvent.\n * @private @const {string}\n */\ngoog.events.LISTENER_WRAPPER_PROP_ =\n    '__closure_events_fn_' + ((Math.random() * 1e9) >>> 0);\n\n\n/**\n * @param {Object|Function} listener The listener function or an\n *     object that contains handleEvent method.\n * @return {!Function} Either the original function or a function that\n *     calls obj.handleEvent. If the same listener is passed to this\n *     function more than once, the same function is guaranteed to be\n *     returned.\n */\ngoog.events.wrapListener = function(listener) {\n  goog.asserts.assert(listener, 'Listener can not be null.');\n\n  if (goog.isFunction(listener)) {\n    return listener;\n  }\n\n  goog.asserts.assert(\n      listener.handleEvent, 'An object listener must have handleEvent method.');\n  if (!listener[goog.events.LISTENER_WRAPPER_PROP_]) {\n    listener[goog.events.LISTENER_WRAPPER_PROP_] = function(e) {\n      return /** @type {?} */ (listener).handleEvent(e);\n    };\n  }\n  return listener[goog.events.LISTENER_WRAPPER_PROP_];\n};\n\n\n// Register the browser event handler as an entry point, so that\n// it can be monitored for exception handling, etc.\ngoog.debug.entryPointRegistry.register(\n    /**\n     * @param {function(!Function): !Function} transformer The transforming\n     *     function.\n     */\n    function(transformer) {\n      goog.events.handleBrowserEvent_ =\n          transformer(goog.events.handleBrowserEvent_);\n    });\n"],
"names":["goog","provide","forwardDeclare","require","events","Key","ListenableType","LISTENER_MAP_PROP_","Math","random","onString_","onStringMap_","CaptureSimulationMode","OFF_AND_FAIL","OFF_AND_SILENT","ON","CAPTURE_SIMULATION_MODE","define","listenerCountEstimate_","listen","goog.events.listen","src","type","listener","opt_options","opt_handler","once","listenOnce","isArray","i","length","wrapListener","Listenable","isImplementedBy","capture","isObject","listen_","goog.events.listen_","callOnce","Error","BrowserFeature","HAS_W3C_EVENT_SUPPORT","asserts","fail","listenerMap","getListenerMap_","ListenerMap","listenerObj","add","proxy","getProxy","addEventListener","PASSIVE_EVENTS","undefined","toString","attachEvent","getOnString_","addListener","removeListener","assert","goog.events.getProxy","proxyCallbackFunction","handleBrowserEvent_","f","eventObject","call","v","goog.events.listenOnce","listenWithWrapper","goog.events.listenWithWrapper","wrapper","opt_capt","unlisten","goog.events.unlisten","getListener","unlistenByKey","goog.events.unlistenByKey","key","removed","removeEventListener","detachEvent","removeByKey","getTypeCount","markAsRemoved","unlistenWithWrapper","goog.events.unlistenWithWrapper","removeAll","goog.events.removeAll","obj","opt_type","removeAllListeners","count","typeStr","listeners","concat","getListeners","goog.events.getListeners","goog.events.getListener","hasListener","goog.events.hasListener","opt_capture","expose","goog.events.expose","e","str","id","push","join","goog.events.getOnString_","fireListeners","goog.events.fireListeners","fireListeners_","goog.events.fireListeners_","retval","listenerArray","result","fireListener","goog.events.fireListener","listenerFn","listenerHandler","handler","getTotalListenerCount","goog.events.getTotalListenerCount","dispatchEvent","goog.events.dispatchEvent","protectBrowserEventEntryPoint","goog.events.protectBrowserEventEntryPoint","errorHandler","protectEntryPoint","goog.events.handleBrowserEvent_","opt_evt","ieEvent","getObjectByName","evt","BrowserEvent","isMarkedIeEvent_","markIeEvent_","ancestors","parent","currentTarget","parentNode","propagationStopped_","goog.events.markIeEvent_","useReturnValue","keyCode","ex","returnValue","goog.events.isMarkedIeEvent_","uniqueIdCounter_","getUniqueId","goog.events.getUniqueId","identifier","goog.events.getListenerMap_","LISTENER_WRAPPER_PROP_","goog.events.wrapListener","isFunction","handleEvent","debug","entryPointRegistry","register","transformer"]
}
