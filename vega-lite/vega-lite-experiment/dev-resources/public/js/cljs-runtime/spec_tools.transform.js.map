{"version":3,"sources":["spec_tools/transform.cljc"],"mappings":"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","names":["spec-tools.transform/keyword->string","_","x","cljs.core/Keyword","spec-tools.impl/qualified-name","spec-tools.transform/keyword-or-string->","f","spec","G__77716","G__77717","spec-tools.transform/keyword->","G__77719","G__77720","spec-tools.transform/number->string","spec-tools.transform/number-or-string->","G__77730","G__77731","spec-tools.transform/string->long","e77736","x'","js/parseInt","js/isNaN","js/Error","spec-tools.transform/string->double","e77737","js/parseFloat","spec-tools.transform/string->keyword","cljs.core.keyword","spec-tools.transform/string->boolean","cljs.core._EQ_","spec-tools.transform/string->uri","e77738","js/goog.Uri.parse","spec-tools.transform/string->uuid","e77739","cljs.core/re-find","cljs.core/uuid","spec-tools.transform/string->date","e77748","js/Date","js/goog.date.UtcDateTime.fromIsoString","spec-tools.transform/date->string","cljs.core/inst?","e77753","spec-tools.transform/string->symbol","cljs.core.symbol","spec-tools.transform/string->nil","spec-tools.transform/any->string","spec-tools.transform/number->double","spec-tools.transform/any->any","p__77780","map__77781","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply","cljs.core/hash-map","keys","cljs.core.get","spec-tools.transform/strip-extra-keys","and__4115__auto__","cljs.core/map?","cljs.core/select-keys","p__77783","map__77784","spec-tools.transform/fail-on-extra-keys","clojure.set/subset?","cljs.core/keys","cljs.core/set","p__77786","map__77787","items","spec-tools.transform/strip-extra-values","size","cljs.core/count","cljs.core/vector?","cljs.core.subvec","spec-tools.transform/json-type-decoders","cljs.core.merge","spec-tools.transform/string-type-decoders","spec-tools.transform/strip-extra-keys-type-decoders","spec-tools.transform/fail-on-extra-keys-type-decoders","spec-tools.transform/strip-extra-values-type-decoders","spec-tools.transform/json-type-encoders","spec-tools.transform/string-type-encoders"],"sourcesContent":["(ns spec-tools.transform\n  #?(:cljs (:refer-clojure :exclude [Inst Keyword UUID]))\n  (:require [clojure.spec.alpha :as s]\n            #?@(:cljs [[goog.date.UtcDateTime]\n                       [goog.date.Date]\n                       [goog.Uri]])\n            [clojure.set :as set]\n            [clojure.edn :as edn]\n            [spec-tools.parse :as parse]\n            [spec-tools.impl :as impl])\n  #?(:clj\n     (:import (java.util Date UUID)\n              (java.time Instant ZoneId)\n              (java.net URI)\n              (java.time.format DateTimeFormatter DateTimeFormatterBuilder)\n              (java.time.temporal ChronoField))))\n\n;;\n;; Keywords\n;;\n\n(defn keyword->string [_ x]\n  (if (keyword? x)\n    (impl/qualified-name x)\n    x))\n\n(defn keyword-or-string-> [f]\n  (fn [spec x]\n    (cond\n      (keyword? x) (f spec (keyword->string spec x))\n      (string? x) (f spec x)\n      :else x)))\n\n(defn keyword-> [f]\n  (fn [spec x]\n    (cond\n      (keyword? x) (f spec (keyword->string spec x))\n      :else x)))\n\n;; Numbers\n;;\n\n(defn number->string [_ x]\n  (if (number? x)\n    (str x)\n    x))\n\n(defn number-or-string-> [f]\n  (fn [spec x]\n    (cond\n      (number? x) (f spec (number->string spec x))\n      (string? x) (f spec x)\n      :else x)))\n;;\n;; Strings\n;;\n\n(defn string->long [_ x]\n  (if (string? x)\n    (try\n      #?(:clj  (Long/parseLong x)\n         :cljs (let [x' (js/parseInt x 10)]\n                 (if (js/isNaN x') x x')))\n      (catch #?(:clj Exception, :cljs js/Error) _ x))\n    x))\n\n(defn string->double [_ x]\n  (if (string? x)\n    (try\n      #?(:clj  (Double/parseDouble x)\n         :cljs (let [x' (js/parseFloat x)]\n                 (if (js/isNaN x') x x')))\n      (catch #?(:clj Exception, :cljs js/Error) _ x))\n    x))\n\n(defn string->keyword [_ x]\n  (if (string? x)\n    (keyword x)\n    x))\n\n(defn string->boolean [_ x]\n  (if (string? x)\n    (cond\n      (= \"true\" x) true\n      (= \"false\" x) false\n      :else x)\n    x))\n\n#?(:clj\n   (defn string->decimal [_ x]\n     (if (string? x)\n       (try\n         (BigDecimal. ^String x)\n         (catch Exception _ x))\n       x)))\n\n#?(:clj\n   (defn string->ratio [_ x]\n     (if (string? x)\n       (try\n         (let [parsed-x (edn/read-string ^String x)]\n           (if (ratio? parsed-x)\n             parsed-x\n             x))\n         (catch Exception _ x))\n       x)))\n\n(defn string->uri [_ x]\n  (if (string? x)\n    (try\n      #?(:clj  (URI/create x)\n         ;; https://stackoverflow.com/questions/11528249/uri-validation-in-javascript\n         :cljs (goog.Uri.parse x))\n      (catch #?(:clj Exception, :cljs js/Error) _ x))\n    x))\n\n(defn string->uuid [_ x]\n  (if (string? x)\n    (try\n      #?(:clj  (UUID/fromString x)\n         ;; http://stackoverflow.com/questions/7905929/how-to-test-valid-uuid-guid\n         :cljs (if (re-find #\"^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\" x)\n                 (uuid x)\n                 x))\n      (catch #?(:clj Exception, :cljs js/Error) _ x))\n    x))\n\n#?(:clj\n   (def ^DateTimeFormatter +string->date-format+\n     (-> (DateTimeFormatterBuilder.)\n         (.appendPattern \"yyyy-MM-dd['T'HH:mm:ss[.SSS][XXXX][XXXXX]]\")\n         (.parseDefaulting ChronoField/HOUR_OF_DAY 0)\n         (.parseDefaulting ChronoField/OFFSET_SECONDS 0)\n         (.toFormatter))))\n\n(defn string->date [_ x]\n  (if (string? x)\n    (try\n      #?(:clj  (Date/from (Instant/from (.parse +string->date-format+ x)))\n         :cljs (js/Date. (.getTime (goog.date.UtcDateTime.fromIsoString x))))\n      (catch #?(:clj Exception, :cljs js/Error) _ x))\n    x))\n\n#?(:clj\n   (def ^DateTimeFormatter +date->string-format+\n     (-> (DateTimeFormatter/ofPattern \"yyyy-MM-dd'T'HH:mm:ss.SSSXXX\")\n         (.withZone (ZoneId/of \"UTC\")))))\n\n(defn date->string [_ x]\n  (if (inst? x)\n    (try\n      #?(:clj  (.format +date->string-format+ (Instant/ofEpochMilli (inst-ms x)))\n         :cljs (.toISOString x))\n      (catch #?(:clj Exception, :cljs js/Error) _ x))\n    x))\n\n(defn string->symbol [_ x]\n  (if (string? x)\n    (symbol x)\n    x))\n\n(defn string->nil [_ x]\n  (if (= \"\" x)\n    nil\n    x))\n\n(defn any->string [_ x]\n  (if-not (nil? x)\n    (str x)))\n\n(defn number->double [_ x]\n  (if (number? x)\n    (double x)\n    x))\n\n(defn any->any [_ x] x)\n\n;;\n;; Maps\n;;\n\n(defn strip-extra-keys [{:keys [::parse/keys]} x]\n  (if (and keys (map? x))\n    (select-keys x keys)\n    x))\n\n;; TODO: remove this as it couples transformation & validation?\n(defn fail-on-extra-keys [{:keys [::parse/keys]} x]\n  (if (and (map? x) (not (set/subset? (-> x (clojure.core/keys) (set)) keys)))\n    ::s/invalid\n    x))\n\n;;\n;; Tuples\n;;\n\n(defn strip-extra-values [{:keys [::parse/items]} x]\n  (let [size (count items)]\n    (if (and (vector? x) (> (count x) size))\n      (subvec x 0 size)\n      x)))\n\n;;\n;; type decoders\n;;\n\n(def json-type-decoders\n  (merge\n    {:keyword string->keyword\n     :uuid (keyword-or-string-> string->uuid)\n     :date (keyword-or-string-> string->date)\n     :symbol (keyword-or-string-> string->symbol)\n     :long (keyword-> string->long)\n     :double (keyword-> string->double)\n     :boolean (keyword-> string->boolean)\n     :string keyword->string}\n    #?(:clj\n       {:uri string->uri\n        :bigdec (number-or-string-> string->decimal)\n        :ratio string->ratio})))\n\n(def string-type-decoders\n  (merge\n    json-type-decoders\n    {:long (keyword-or-string-> string->long)\n     :double (keyword-or-string-> string->double)\n     :boolean (keyword-or-string-> string->boolean)}))\n\n(def strip-extra-keys-type-decoders\n  {:map strip-extra-keys})\n\n(def fail-on-extra-keys-type-decoders\n  {:map fail-on-extra-keys})\n\n(def strip-extra-values-type-decoders\n  {:tuple strip-extra-values})\n\n;;\n;; type encoders\n;;\n\n(def json-type-encoders\n  {:keyword keyword->string\n   :symbol any->string\n   :uuid any->string\n   :uri any->string\n   :bigdec any->string\n   :date date->string\n   :map any->any\n   :set any->any\n   :vector any->any\n   #?@(:clj [:ratio number->double])})\n\n(def string-type-encoders\n  (merge\n    json-type-encoders\n    {:long any->string\n     :double any->string}))\n"]}